"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const proto_1 = require("@xmtp/proto");
const PrivateKeyBundle_1 = require("./../crypto/PrivateKeyBundle");
const Invitation_1 = require("./../Invitation");
const encryption_1 = require("./encryption");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
const utils_2 = require("../utils");
const InviteStore_1 = __importDefault(require("./InviteStore"));
const LocalAuthenticator_1 = __importDefault(require("../authn/LocalAuthenticator"));
const { ErrorCode } = proto_1.keystore;
class InMemoryKeystore {
    constructor(keys, inviteStore) {
        this.v1Keys = keys;
        this.v2Keys = PrivateKeyBundle_1.PrivateKeyBundleV2.fromLegacyBundle(keys);
        this.inviteStore = inviteStore;
        this.authenticator = new LocalAuthenticator_1.default(keys.identityKey);
    }
    static async create(keys, persistence) {
        return new InMemoryKeystore(keys, await InviteStore_1.default.create(persistence));
    }
    async decryptV1(req) {
        const responses = await (0, utils_1.mapAndConvertErrors)(req.requests, async (req) => {
            if (!(0, utils_1.validateObject)(req, ['payload', 'peerKeys'], ['headerBytes'])) {
                throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'invalid');
            }
            const { payload, peerKeys, headerBytes, isSender } = req;
            const decrypted = await (0, encryption_1.decryptV1)(this.v1Keys, (0, utils_1.toPublicKeyBundle)(peerKeys), payload, headerBytes, isSender);
            return {
                decrypted,
            };
        }, proto_1.keystore.ErrorCode.ERROR_CODE_UNSPECIFIED);
        return proto_1.keystore.DecryptResponse.fromPartial({
            responses,
        });
    }
    async decryptV2(req) {
        const responses = await (0, utils_1.mapAndConvertErrors)(req.requests, async (req) => {
            if (!(0, utils_1.validateObject)(req, ['payload'], ['headerBytes'])) {
                throw new errors_1.KeystoreError(proto_1.keystore.ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
            }
            const { payload, headerBytes, contentTopic } = req;
            const topicData = this.inviteStore.lookup(contentTopic);
            if (!topicData) {
                // This is the wrong error type. Will add to the proto repo later
                throw new errors_1.KeystoreError(proto_1.keystore.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, 'no topic key');
            }
            const decrypted = await (0, encryption_1.decryptV2)(payload, (0, utils_1.getKeyMaterial)(topicData.invitation), headerBytes);
            return { decrypted };
        }, ErrorCode.ERROR_CODE_UNSPECIFIED);
        return proto_1.keystore.DecryptResponse.fromPartial({
            responses,
        });
    }
    async encryptV1(req) {
        const responses = await (0, utils_1.mapAndConvertErrors)(req.requests, async (req) => {
            if (!(0, utils_1.validateObject)(req, ['payload', 'recipient'], ['headerBytes'])) {
                throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
            }
            const { recipient, payload, headerBytes } = req;
            return {
                encrypted: await (0, encryption_1.encryptV1)(this.v1Keys, (0, utils_1.toPublicKeyBundle)(recipient), payload, headerBytes),
            };
        }, ErrorCode.ERROR_CODE_UNSPECIFIED);
        return proto_1.keystore.EncryptResponse.fromPartial({
            responses,
        });
    }
    async createAuthToken({ timestampNs, }) {
        return this.authenticator.createToken(timestampNs ? (0, utils_2.nsToDate)(timestampNs) : undefined);
    }
    async encryptV2(req) {
        const responses = await (0, utils_1.mapAndConvertErrors)(req.requests, async (req) => {
            if (!(0, utils_1.validateObject)(req, ['payload'], ['headerBytes'])) {
                throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
            }
            const { payload, headerBytes, contentTopic } = req;
            const topicData = this.inviteStore.lookup(contentTopic);
            if (!topicData) {
                throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, 'no topic key');
            }
            return {
                encrypted: await (0, encryption_1.encryptV2)(payload, (0, utils_1.getKeyMaterial)(topicData.invitation), headerBytes),
            };
        }, ErrorCode.ERROR_CODE_INVALID_INPUT);
        return proto_1.keystore.EncryptResponse.fromPartial({
            responses,
        });
    }
    async saveInvites(req) {
        const toAdd = [];
        const responses = await (0, utils_1.mapAndConvertErrors)(req.requests, async ({ payload, timestampNs }) => {
            const sealed = Invitation_1.SealedInvitation.fromBytes(payload);
            if (sealed.v1) {
                const headerTime = sealed.v1.header.createdNs;
                if (!headerTime.equals(timestampNs)) {
                    throw new Error('envelope and header timestamp mismatch');
                }
                const isSender = sealed.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle());
                const invitation = await sealed.v1.getInvitation(this.v2Keys);
                const topicData = {
                    invitation,
                    createdNs: sealed.v1.header.createdNs,
                    peerAddress: isSender
                        ? await sealed.v1.header.recipient.walletSignatureAddress()
                        : await sealed.v1.header.sender.walletSignatureAddress(),
                };
                toAdd.push(topicData);
                return {
                    conversation: (0, utils_1.topicDataToConversationReference)(topicData),
                };
            }
        }, ErrorCode.ERROR_CODE_INVALID_INPUT);
        await this.inviteStore.add(toAdd);
        return proto_1.keystore.SaveInvitesResponse.fromPartial({
            responses,
        });
    }
    async createInvite(req) {
        try {
            if (!(0, utils_1.validateObject)(req, ['recipient'], [])) {
                throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing recipient');
            }
            const invitation = Invitation_1.InvitationV1.createRandom(req.context);
            const created = (0, utils_2.nsToDate)(req.createdNs);
            const recipient = (0, utils_1.toSignedPublicKeyBundle)(req.recipient);
            const sealed = await Invitation_1.SealedInvitation.createV1({
                sender: this.v2Keys,
                recipient,
                created,
                invitation,
            });
            const topicData = {
                invitation,
                createdNs: req.createdNs,
                peerAddress: await recipient.walletSignatureAddress(),
            };
            await this.inviteStore.add([topicData]);
            return proto_1.keystore.CreateInviteResponse.fromPartial({
                conversation: (0, utils_1.topicDataToConversationReference)(topicData),
                payload: sealed.toBytes(),
            });
        }
        catch (e) {
            throw (0, utils_1.convertError)(e, ErrorCode.ERROR_CODE_INVALID_INPUT);
        }
    }
    async signDigest(req) {
        if (!(0, utils_1.validateObject)(req, ['digest'], [])) {
            throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
        }
        const { digest, identityKey, prekeyIndex } = req;
        let key;
        if (identityKey) {
            key = this.v1Keys.identityKey;
        }
        else if (typeof prekeyIndex !== 'undefined' &&
            Number.isInteger(prekeyIndex)) {
            key = this.v1Keys.preKeys[prekeyIndex];
            if (!key) {
                throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, 'no prekey found');
            }
        }
        else {
            throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'must specifify identityKey or prekeyIndex');
        }
        return key.sign(digest);
    }
    async getV2Conversations() {
        const convos = this.inviteStore.topics.map((invite) => (0, utils_1.topicDataToConversationReference)(invite));
        convos.sort((a, b) => a.createdNs.div(1000000).sub(b.createdNs.div(1000000)).toNumber());
        return convos;
    }
    async getPublicKeyBundle() {
        return this.v1Keys.getPublicKeyBundle();
    }
    async getPrivateKeyBundle() {
        return this.v1Keys;
    }
    async getAccountAddress() {
        if (!this.accountAddress) {
            this.accountAddress = await this.v2Keys
                .getPublicKeyBundle()
                .walletSignatureAddress();
        }
        return this.accountAddress;
    }
    // This method is not defined as part of the standard Keystore API, but is available
    // on the InMemoryKeystore to support legacy use-cases.
    lookupTopic(topic) {
        return this.inviteStore.lookup(topic);
    }
}
exports.default = InMemoryKeystore;
//# sourceMappingURL=InMemoryKeystore.js.map