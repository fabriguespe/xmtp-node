"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ecies_1 = require("../../crypto/ecies");
const crypto_1 = require("../../crypto");
/**
 * EncryptedPersistence is a Persistence implementation that uses ECIES to encrypt all values
 * ECIES encryption protects against unauthorized reads, but not unauthorized writes.
 * A third party with access to the underlying store could write malicious data using the public key of the owner
 */
class EncryptedPersistence {
    constructor(persistence, privateKey) {
        this.persistence = persistence;
        this.privateKey = privateKey;
        this.privateKeyBytes = Buffer.from(privateKey.secp256k1.bytes);
        this.publicKey = (0, ecies_1.getPublic)(this.privateKeyBytes);
    }
    async getItem(key) {
        const encrypted = await this.persistence.getItem(key);
        if (encrypted) {
            return this.decrypt(encrypted);
        }
        return null;
    }
    async setItem(key, value) {
        const encrypted = await this.encrypt(value);
        await this.persistence.setItem(key, encrypted);
    }
    async encrypt(value) {
        const ecies = await (0, ecies_1.encrypt)(this.publicKey, Buffer.from(value));
        return this.serializeEcies(ecies);
    }
    async decrypt(value) {
        const ecies = await this.deserializeEcies(value);
        const result = await (0, ecies_1.decrypt)(this.privateKeyBytes, ecies);
        return Uint8Array.from(result);
    }
    async serializeEcies(data) {
        // This will create and sign a `SignedEciesCiphertext` payload based on the provided data
        const protoVal = await crypto_1.SignedEciesCiphertext.create(data, this.privateKey);
        return protoVal.toBytes();
    }
    async deserializeEcies(data) {
        const protoVal = crypto_1.SignedEciesCiphertext.fromBytes(data);
        // Verify the signature upon deserializing
        if (!(await protoVal.verify(this.privateKey.publicKey))) {
            throw new Error('signature validation failed');
        }
        const ecies = protoVal.ciphertext;
        return {
            ciphertext: Buffer.from(ecies.ciphertext),
            mac: Buffer.from(ecies.mac),
            iv: Buffer.from(ecies.iv),
            ephemeralPublicKey: Buffer.from(ecies.ephemeralPublicKey),
        };
    }
}
exports.default = EncryptedPersistence;
//# sourceMappingURL=EncryptedPersistence.js.map