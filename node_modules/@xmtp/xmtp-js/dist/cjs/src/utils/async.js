"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapPaginatedStream = exports.retry = exports.promiseWithTimeout = exports.sleep = void 0;
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
exports.sleep = sleep;
const promiseWithTimeout = (timeoutMs, promise, failureMessage) => {
    let timeoutHandle;
    const timeoutPromise = new Promise((_resolve, reject) => {
        timeoutHandle = setTimeout(() => reject(new Error(failureMessage)), timeoutMs);
    });
    return Promise.race([promise(), timeoutPromise]).then((result) => {
        clearTimeout(timeoutHandle);
        return result;
    });
};
exports.promiseWithTimeout = promiseWithTimeout;
const defaultIsRetryableFn = (err) => !!err;
// Implements type safe retries of arbitrary async functions
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function retry(fn, args, maxRetries, sleepTime, isRetryableFn = defaultIsRetryableFn, retryCount = 1) {
    const currRetry = typeof retryCount === 'number' ? retryCount : 1;
    try {
        const result = await fn(...args);
        return result;
    }
    catch (e) {
        if (!isRetryableFn(e) || currRetry > maxRetries) {
            throw e;
        }
        await (0, exports.sleep)(sleepTime);
        return retry(fn, args, maxRetries, sleepTime, isRetryableFn, currRetry + 1);
    }
}
exports.retry = retry;
// Takes an async generator returning pages of envelopes and converts to an async
// generator returning pages of an arbitrary type using a mapper function
async function* mapPaginatedStream(gen, mapper) {
    for await (const page of gen) {
        const results = await Promise.allSettled(page.map(mapper));
        const out = [];
        for (const result of results) {
            if (result.status === 'fulfilled') {
                out.push(result.value);
            }
            else {
                console.warn('Failed to process envelope due to reason: ', result.reason);
            }
        }
        yield out;
    }
}
exports.mapPaginatedStream = mapPaginatedStream;
//# sourceMappingURL=async.js.map