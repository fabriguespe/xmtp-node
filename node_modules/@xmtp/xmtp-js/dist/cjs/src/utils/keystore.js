"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildDecryptV1Request = exports.getResultOrThrow = void 0;
const proto_1 = require("@xmtp/proto");
const PublicKeyBundle_1 = require("../crypto/PublicKeyBundle");
const errors_1 = require("../keystore/errors");
// Validates the Keystore response. Throws on errors or missing fields.
// Returns a type with all possibly undefined fields required to be defined
const getResultOrThrow = (response) => {
    if (response.error) {
        throw new errors_1.KeystoreError(response.error.code, response.error.message);
    }
    if (!response.result) {
        throw new errors_1.KeystoreError(proto_1.keystore.ErrorCode.ERROR_CODE_UNSPECIFIED, 'No result from Keystore');
    }
    if ('encrypted' in response.result && !response.result.encrypted) {
        throw new Error('Missing ciphertext');
    }
    if ('decrypted' in response.result && !response.result.decrypted) {
        throw new Error('Missing decrypted result');
    }
    return response.result;
};
exports.getResultOrThrow = getResultOrThrow;
const buildDecryptV1Request = (messages, myPublicKeyBundle) => {
    return {
        requests: messages.map((m) => {
            const sender = new PublicKeyBundle_1.PublicKeyBundle({
                identityKey: m.header.sender?.identityKey,
                preKey: m.header.sender?.preKey,
            });
            const isSender = myPublicKeyBundle.equals(sender);
            return {
                payload: m.ciphertext,
                peerKeys: isSender
                    ? new PublicKeyBundle_1.PublicKeyBundle({
                        identityKey: m.header.recipient?.identityKey,
                        preKey: m.header.recipient?.preKey,
                    })
                    : sender,
                headerBytes: m.headerBytes,
                isSender,
            };
        }),
    };
};
exports.buildDecryptV1Request = buildDecryptV1Request;
//# sourceMappingURL=keystore.js.map