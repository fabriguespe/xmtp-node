import { messageApi } from '@xmtp/proto';
import { retry, sleep, toNanoString } from './utils';
import AuthCache from './authn/AuthCache';
import packageJson from '../package.json';
import { XMTP_DEV_WARNING } from './constants';
export const { MessageApi, SortDirection } = messageApi;
const RETRY_SLEEP_TIME = 100;
const ERR_CODE_UNAUTHENTICATED = 16;
const clientVersionHeaderKey = 'X-Client-Version';
const appVersionHeaderKey = 'X-App-Version';
export const ApiUrls = {
    local: 'http://localhost:5555',
    dev: 'https://dev.xmtp.network',
    production: 'https://production.xmtp.network',
};
export var GrpcStatus;
(function (GrpcStatus) {
    GrpcStatus[GrpcStatus["OK"] = 0] = "OK";
    GrpcStatus[GrpcStatus["CANCELLED"] = 1] = "CANCELLED";
    GrpcStatus[GrpcStatus["UNKNOWN"] = 2] = "UNKNOWN";
    GrpcStatus[GrpcStatus["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    GrpcStatus[GrpcStatus["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    GrpcStatus[GrpcStatus["NOT_FOUND"] = 5] = "NOT_FOUND";
    GrpcStatus[GrpcStatus["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    GrpcStatus[GrpcStatus["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    GrpcStatus[GrpcStatus["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    GrpcStatus[GrpcStatus["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    GrpcStatus[GrpcStatus["ABORTED"] = 10] = "ABORTED";
    GrpcStatus[GrpcStatus["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    GrpcStatus[GrpcStatus["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    GrpcStatus[GrpcStatus["INTERNAL"] = 13] = "INTERNAL";
    GrpcStatus[GrpcStatus["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    GrpcStatus[GrpcStatus["DATA_LOSS"] = 15] = "DATA_LOSS";
    GrpcStatus[GrpcStatus["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
})(GrpcStatus || (GrpcStatus = {}));
export class GrpcError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
    }
    static fromObject(err) {
        return new GrpcError(err.message, err.code);
    }
}
const isAbortError = (err) => {
    if (!err) {
        return false;
    }
    if (err.name === 'AbortError' || err.message.includes('aborted')) {
        return true;
    }
    return false;
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isAuthError = (err) => {
    if (err && 'code' in err && err.code === ERR_CODE_UNAUTHENTICATED) {
        return true;
    }
    return false;
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isNotAuthError = (err) => !isAuthError(err);
/**
 * ApiClient provides a wrapper for calling the GRPC Gateway generated code.
 * It adds some helpers for dealing with paginated data and automatically retries idempotent calls
 */
export default class ApiClient {
    constructor(pathPrefix, opts) {
        this.pathPrefix = pathPrefix;
        this.maxRetries = opts?.maxRetries || 5;
        this.appVersion = opts?.appVersion;
        this.version = 'xmtp-js/' + packageJson.version;
        if (pathPrefix === ApiUrls.dev) {
            console.info(XMTP_DEV_WARNING);
        }
    }
    // Raw method for querying the API
    async _query(req) {
        try {
            return await retry(MessageApi.Query, [
                req,
                {
                    pathPrefix: this.pathPrefix,
                    mode: 'cors',
                    headers: this.headers(),
                },
            ], this.maxRetries, RETRY_SLEEP_TIME);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (e) {
            throw GrpcError.fromObject(e);
        }
    }
    // Raw method for batch-querying the API
    _batchQuery(req) {
        return retry(MessageApi.BatchQuery, [
            req,
            {
                pathPrefix: this.pathPrefix,
                mode: 'cors',
                headers: this.headers(),
            },
        ], this.maxRetries, RETRY_SLEEP_TIME);
    }
    // Raw method for publishing to the API
    async _publish(req, attemptNumber = 0) {
        const authToken = await this.getToken();
        const headers = this.headers();
        headers.set('Authorization', `Bearer ${authToken}`);
        try {
            return await retry(MessageApi.Publish, [
                req,
                {
                    pathPrefix: this.pathPrefix,
                    mode: 'cors',
                    headers,
                },
            ], this.maxRetries, RETRY_SLEEP_TIME, 
            // Do not retry UnauthenticatedErrors
            isNotAuthError);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (e) {
            // Try at most 2X. If refreshing the auth token doesn't work the first time, it won't work the second time
            if (isNotAuthError(e) || attemptNumber >= 1) {
                throw GrpcError.fromObject(e);
            }
            await this.authCache?.refresh();
            return this._publish(req, attemptNumber + 1);
        }
    }
    // Raw method for subscribing
    _subscribe(req, cb) {
        const abortController = new AbortController();
        const doSubscribe = async () => {
            while (true) {
                const startTime = new Date().getTime();
                try {
                    await MessageApi.Subscribe(req, cb, {
                        pathPrefix: this.pathPrefix,
                        signal: abortController.signal,
                        mode: 'cors',
                        headers: this.headers(),
                    });
                    if (abortController.signal.aborted) {
                        return;
                    }
                    console.info('Stream connection closed. Resubscribing');
                    if (new Date().getTime() - startTime < 1000) {
                        await sleep(1000);
                    }
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                }
                catch (err) {
                    if (isAbortError(err) || abortController.signal.aborted) {
                        return;
                    }
                    console.info('Stream connection closed. Resubscribing', err.toString());
                    if (new Date().getTime() - startTime < 1000) {
                        await sleep(1000);
                    }
                }
            }
        };
        doSubscribe();
        return async () => {
            abortController?.abort();
        };
    }
    // Use the Query API to return the full contents of any specified topics
    async query(params, { direction = SortDirection.SORT_DIRECTION_ASCENDING, limit, }) {
        const out = [];
        // Use queryIteratePages for better performance. 1/100th the number of Promises to resolve compared to queryStream
        for await (const page of this.queryIteratePages(params, {
            direction,
            // If there is a limit of < 100, use that as the page size. Otherwise use 100 and stop if/when limit reached.
            pageSize: limit && limit < 100 ? limit : 100,
        })) {
            for (const envelope of page) {
                out.push(envelope);
                if (limit && out.length === limit) {
                    return out;
                }
            }
        }
        return out;
    }
    // Will produce an AsyncGenerator of Envelopes
    // Uses queryStreamPages under the hood
    async *queryIterator(params, options) {
        for await (const page of this.queryIteratePages(params, options)) {
            for (const envelope of page) {
                yield envelope;
            }
        }
    }
    // Creates an async generator that will paginate through the Query API until it reaches the end
    // Will yield each page of results as needed
    async *queryIteratePages({ contentTopic, startTime, endTime }, { direction, pageSize = 10 }) {
        if (!contentTopic || !contentTopic.length) {
            throw new Error('Must specify content topics');
        }
        const startTimeNs = toNanoString(startTime);
        const endTimeNs = toNanoString(endTime);
        let cursor;
        while (true) {
            const pagingInfo = {
                limit: pageSize,
                direction,
                cursor,
            };
            const result = await this._query({
                contentTopics: [contentTopic],
                startTimeNs,
                endTimeNs,
                pagingInfo,
            });
            if (result.envelopes?.length) {
                yield result.envelopes;
            }
            else {
                return;
            }
            if (result.pagingInfo?.cursor) {
                cursor = result.pagingInfo?.cursor;
            }
            else {
                return;
            }
        }
    }
    // Take a list of queries and execute them in batches
    async batchQuery(queries) {
        // Group queries into batches of 50 (implicit server-side limit) and then perform BatchQueries
        const BATCH_SIZE = 50;
        // Keep a list of BatchQueryRequests to execute all at once later
        const batchRequests = [];
        // Assemble batches
        for (let i = 0; i < queries.length; i += BATCH_SIZE) {
            const queriesInBatch = queries.slice(i, i + BATCH_SIZE);
            // Perform batch query by first compiling a list of repeated individual QueryRequests
            // then populating a BatchQueryRequest with that list
            const constructedQueries = [];
            for (const queryParams of queriesInBatch) {
                constructedQueries.push({
                    contentTopics: [queryParams.contentTopic],
                    startTimeNs: toNanoString(queryParams.startTime),
                    endTimeNs: toNanoString(queryParams.endTime),
                    pagingInfo: {
                        limit: queryParams.pageSize || 10,
                        direction: queryParams.direction || SortDirection.SORT_DIRECTION_ASCENDING,
                    },
                });
            }
            const batchQueryRequest = {
                requests: constructedQueries,
            };
            batchRequests.push(batchQueryRequest);
        }
        // Execute batches
        const batchQueryResponses = await Promise.all(batchRequests.map(async (batch) => this._batchQuery(batch)));
        // For every batch, read all responses within the batch, and add to a list of lists of envelopes
        // one top-level list for every original query
        const allEnvelopes = [];
        for (const batchResponse of batchQueryResponses) {
            if (!batchResponse.responses) {
                // An error on any of the batch query is propagated to the caller
                // for simplicity, rather than trying to return partial results
                throw new Error('BatchQueryResponse missing responses');
            }
            for (const queryResponse of batchResponse.responses) {
                if (queryResponse.envelopes) {
                    allEnvelopes.push(queryResponse.envelopes);
                }
                else {
                    // If no envelopes provided, then add an empty list
                    allEnvelopes.push([]);
                }
            }
        }
        return allEnvelopes;
    }
    // Publish a message to the network
    // Will convert timestamps to the appropriate format expected by the network
    async publish(messages) {
        const toSend = [];
        for (const { contentTopic, message, timestamp } of messages) {
            if (!contentTopic.length) {
                throw new Error('Content topic cannot be empty string');
            }
            if (!message.length) {
                throw new Error('0 length messages not allowed');
            }
            const dt = timestamp || new Date();
            toSend.push({
                contentTopic,
                timestampNs: toNanoString(dt),
                message: Uint8Array.from(message),
            });
        }
        return this._publish({ envelopes: toSend });
    }
    // Subscribe to a list of topics.
    // Provided callback function will be called on each new message
    // Returns an unsubscribe function that can be used to end the subscription
    subscribe(params, callback) {
        if (!params.contentTopics.length) {
            throw new Error('Must provide list of contentTopics to subscribe to');
        }
        return this._subscribe(params, callback);
    }
    getToken() {
        if (!this.authCache) {
            throw new Error('AuthCache is not set on API Client');
        }
        return this.authCache.getToken();
    }
    setAuthenticator(authenticator, cacheExpirySeconds) {
        this.authCache = new AuthCache(authenticator, cacheExpirySeconds);
    }
    headers() {
        const headers = new Headers();
        headers.set(clientVersionHeaderKey, this.version);
        if (this.appVersion) {
            headers.set(appVersionHeaderKey, this.appVersion);
        }
        return headers;
    }
}
//# sourceMappingURL=ApiClient.js.map