import Long from 'long';
import { SignedPublicKeyBundle } from './crypto/PublicKeyBundle';
import { invitation, fetcher } from '@xmtp/proto';
import crypto from './crypto/crypto';
import Ciphertext from './crypto/Ciphertext';
import { decrypt, encrypt } from './crypto';
import { dateToNs, buildDirectMessageTopicV2 } from './utils';
const { b64Decode } = fetcher;
/**
 * InvitationV1 is a protobuf message to be encrypted and used as the ciphertext in a SealedInvitationV1 message
 */
export class InvitationV1 {
    constructor({ topic, context, aes256GcmHkdfSha256, }) {
        if (!topic || !topic.length) {
            throw new Error('Missing topic');
        }
        if (!aes256GcmHkdfSha256 ||
            !aes256GcmHkdfSha256.keyMaterial ||
            !aes256GcmHkdfSha256.keyMaterial.length) {
            throw new Error('Missing key material');
        }
        this.topic = topic;
        this.context = context;
        this.aes256GcmHkdfSha256 = aes256GcmHkdfSha256;
    }
    static createRandom(context) {
        const topic = buildDirectMessageTopicV2(Buffer.from(crypto.getRandomValues(new Uint8Array(32)))
            .toString('base64')
            .replace(/=*$/g, '')
            // Replace slashes with dashes so that the topic is still easily split by /
            // We do not treat this as needing to be valid Base64 anywhere
            .replace('/', '-'));
        const keyMaterial = crypto.getRandomValues(new Uint8Array(32));
        return new InvitationV1({
            topic,
            aes256GcmHkdfSha256: { keyMaterial },
            context,
        });
    }
    toBytes() {
        return invitation.InvitationV1.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new InvitationV1(invitation.InvitationV1.decode(bytes));
    }
}
/**
 * SealedInvitationHeaderV1 is a protobuf message to be used as the headerBytes in a SealedInvitationV1
 */
export class SealedInvitationHeaderV1 {
    constructor({ sender, recipient, createdNs, }) {
        if (!sender) {
            throw new Error('Missing sender');
        }
        if (!recipient) {
            throw new Error('Missing recipient');
        }
        this.sender = new SignedPublicKeyBundle(sender);
        this.recipient = new SignedPublicKeyBundle(recipient);
        this.createdNs = createdNs;
    }
    toBytes() {
        return invitation.SealedInvitationHeaderV1.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new SealedInvitationHeaderV1(invitation.SealedInvitationHeaderV1.decode(bytes));
    }
}
export class SealedInvitationV1 {
    constructor({ headerBytes, ciphertext }) {
        if (!headerBytes || !headerBytes.length) {
            throw new Error('Missing header bytes');
        }
        if (!ciphertext) {
            throw new Error('Missing ciphertext');
        }
        this.headerBytes = headerBytes;
        this.ciphertext = new Ciphertext(ciphertext);
    }
    /**
     * Accessor method for the full header object
     */
    get header() {
        // Use cached value if already exists
        if (this._header) {
            return this._header;
        }
        this._header = SealedInvitationHeaderV1.fromBytes(this.headerBytes);
        return this._header;
    }
    /**
     * getInvitation decrypts and returns the InvitationV1 stored in the ciphertext of the Sealed Invitation
     */
    async getInvitation(viewer) {
        // Use cached value if already exists
        if (this._invitation) {
            return this._invitation;
        }
        // The constructors for child classes will validate that this is complete
        const header = this.header;
        let secret;
        if (viewer.identityKey.matches(this.header.sender.identityKey)) {
            secret = await viewer.sharedSecret(header.recipient, header.sender.preKey, false);
        }
        else {
            secret = await viewer.sharedSecret(header.sender, header.recipient.preKey, true);
        }
        const decryptedBytes = await decrypt(this.ciphertext, secret, this.headerBytes);
        this._invitation = InvitationV1.fromBytes(decryptedBytes);
        return this._invitation;
    }
    toBytes() {
        return invitation.SealedInvitationV1.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new SealedInvitationV1(invitation.SealedInvitationV1.decode(bytes));
    }
}
/**
 * Wrapper class for SealedInvitationV1 and any future iterations of SealedInvitation
 */
export class SealedInvitation {
    constructor({ v1 }) {
        if (v1) {
            this.v1 = new SealedInvitationV1(v1);
        }
        else {
            throw new Error('Missing v1 or v2 invitation');
        }
    }
    toBytes() {
        return invitation.SealedInvitation.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new SealedInvitation(invitation.SealedInvitation.decode(bytes));
    }
    static async fromEnvelope(env) {
        if (!env.message || !env.timestampNs) {
            throw new Error('invalid invitation envelope');
        }
        const sealed = SealedInvitation.fromBytes(b64Decode(env.message));
        const envelopeTime = Long.fromString(env.timestampNs);
        const headerTime = sealed.v1?.header.createdNs;
        if (!headerTime || !headerTime.equals(envelopeTime)) {
            throw new Error('envelope and header timestamp mistmatch');
        }
        return sealed;
    }
    /**
     * Create a SealedInvitation with a SealedInvitationV1 payload
     * Will encrypt all contents and validate inputs
     */
    static async createV1({ sender, recipient, created, invitation, }) {
        const headerBytes = new SealedInvitationHeaderV1({
            sender: sender.getPublicKeyBundle(),
            recipient,
            createdNs: dateToNs(created),
        }).toBytes();
        const secret = await sender.sharedSecret(recipient, sender.getCurrentPreKey().publicKey, false);
        const invitationBytes = invitation.toBytes();
        const ciphertext = await encrypt(invitationBytes, secret, headerBytes);
        return new SealedInvitation({
            v1: { headerBytes, ciphertext },
        });
    }
}
//# sourceMappingURL=Invitation.js.map