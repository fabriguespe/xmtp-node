import { ConversationV1, ConversationV2, } from './conversations/Conversation';
import { message as proto, content as protoContent, } from '@xmtp/proto';
import Long from 'long';
import Ciphertext from './crypto/Ciphertext';
import { PublicKeyBundle, PublicKey } from './crypto';
import { bytesToHex } from './crypto/utils';
import { sha256 } from './crypto/encryption';
import { ContentTypeFallback, ContentTypeId, } from './MessageContent';
import { dateToNs, nsToDate } from './utils';
import { decompress } from './Compression';
import { buildDecryptV1Request, getResultOrThrow } from './utils/keystore';
const headerBytesAndCiphertext = (msg) => {
    if (msg.v1?.ciphertext) {
        return [msg.v1.headerBytes, new Ciphertext(msg.v1.ciphertext)];
    }
    if (msg.v2?.ciphertext) {
        return [msg.v2.headerBytes, new Ciphertext(msg.v2.ciphertext)];
    }
    throw new Error('unknown message version');
};
// Message is basic unit of communication on the network.
// Message timestamp is set by the sender.
class MessageBase {
    constructor(id, bytes, obj) {
        ;
        [this.headerBytes, this.ciphertext] = headerBytesAndCiphertext(obj);
        this.id = id;
        this.bytes = bytes;
    }
    toBytes() {
        return this.bytes;
    }
}
// Message header carries the sender and recipient keys used to protect message.
// Message timestamp is set by the sender.
export class MessageV1 extends MessageBase {
    constructor(id, bytes, obj, header, senderAddress) {
        super(id, bytes, obj);
        this.conversation = undefined;
        this.senderAddress = senderAddress;
        this.header = header;
    }
    static async create(obj, header, bytes) {
        if (!header.sender) {
            throw new Error('missing message sender');
        }
        const senderAddress = new PublicKeyBundle(header.sender).walletSignatureAddress();
        const id = bytesToHex(await sha256(bytes));
        return new MessageV1(id, bytes, obj, header, senderAddress);
    }
    get sent() {
        return new Date(this.header.timestamp.toNumber());
    }
    // wallet address derived from the signature of the message recipient
    get recipientAddress() {
        if (!this.header?.recipient?.identityKey) {
            return undefined;
        }
        return new PublicKey(this.header.recipient.identityKey).walletSignatureAddress();
    }
    async decrypt(keystore, myPublicKeyBundle) {
        const responses = (await keystore.decryptV1(buildDecryptV1Request([this], myPublicKeyBundle))).responses;
        if (!responses.length) {
            throw new Error('No response from Keystore');
        }
        const { decrypted } = getResultOrThrow(responses[0]);
        return decrypted;
    }
    static fromBytes(bytes) {
        const message = proto.Message.decode(bytes);
        const [headerBytes] = headerBytesAndCiphertext(message);
        const header = proto.MessageHeaderV1.decode(headerBytes);
        if (!header) {
            throw new Error('missing message header');
        }
        if (!header.sender) {
            throw new Error('missing message sender');
        }
        if (!header.sender.identityKey) {
            throw new Error('missing message sender identity key');
        }
        if (!header.sender.preKey) {
            throw new Error('missing message sender pre-key');
        }
        if (!header.recipient) {
            throw new Error('missing message recipient');
        }
        if (!header.recipient.identityKey) {
            throw new Error('missing message recipient identity-key');
        }
        if (!header.recipient.preKey) {
            throw new Error('missing message recipient pre-key');
        }
        return MessageV1.create(message, header, bytes);
    }
    static async encode(keystore, payload, sender, recipient, timestamp) {
        const header = {
            sender,
            recipient,
            timestamp: Long.fromNumber(timestamp.getTime()),
        };
        const headerBytes = proto.MessageHeaderV1.encode(header).finish();
        const results = await keystore.encryptV1({
            requests: [
                {
                    recipient,
                    headerBytes,
                    payload,
                },
            ],
        });
        if (!results.responses.length) {
            throw new Error('No response from Keystore');
        }
        const { encrypted: ciphertext } = getResultOrThrow(results.responses[0]);
        const protoMsg = {
            v1: { headerBytes, ciphertext },
            v2: undefined,
        };
        const bytes = proto.Message.encode(protoMsg).finish();
        return MessageV1.create(protoMsg, header, bytes);
    }
}
export class MessageV2 extends MessageBase {
    constructor(id, bytes, obj, header) {
        super(id, bytes, obj);
        this.header = header;
    }
    static async create(obj, header, bytes) {
        const id = bytesToHex(await sha256(bytes));
        return new MessageV2(id, bytes, obj, header);
    }
    get sent() {
        return nsToDate(this.header.createdNs);
    }
}
export class DecodedMessage {
    constructor({ id, messageVersion, senderAddress, recipientAddress, conversation, contentBytes, contentType, contentTopic, content, sent, error, }) {
        this.id = id;
        this.messageVersion = messageVersion;
        this.senderAddress = senderAddress;
        this.recipientAddress = recipientAddress;
        this.conversation = conversation;
        this.contentType = contentType;
        this.sent = sent;
        this.error = error;
        this.content = content;
        this.contentTopic = contentTopic;
        this.contentBytes = contentBytes;
    }
    toBytes() {
        return proto.DecodedMessage.encode({
            ...this,
            conversation: {
                topic: this.conversation.topic,
                context: this.conversation.context ?? undefined,
                createdNs: dateToNs(this.conversation.createdAt),
                peerAddress: this.conversation.peerAddress,
            },
            sentNs: dateToNs(this.sent),
        }).finish();
    }
    static async fromBytes(data, client) {
        const protoVal = proto.DecodedMessage.decode(data);
        const messageVersion = protoVal.messageVersion;
        if (messageVersion !== 'v1' && messageVersion !== 'v2') {
            throw new Error('Invalid message version');
        }
        if (!protoVal.conversation) {
            throw new Error('No conversation reference found');
        }
        const { content, contentType, error } = await decodeContent(protoVal.contentBytes, client);
        return new DecodedMessage({
            ...protoVal,
            content,
            contentType,
            error,
            messageVersion,
            sent: nsToDate(protoVal.sentNs),
            conversation: conversationReferenceToConversation(protoVal.conversation, client, messageVersion),
        });
    }
    static fromV1Message(message, content, // eslint-disable-line @typescript-eslint/no-explicit-any
    contentType, contentBytes, contentTopic, conversation, error) {
        const { id, senderAddress, recipientAddress, sent } = message;
        if (!senderAddress) {
            throw new Error('Sender address is required');
        }
        return new DecodedMessage({
            id,
            messageVersion: 'v1',
            senderAddress,
            recipientAddress,
            sent,
            content,
            contentBytes,
            contentType,
            contentTopic,
            conversation,
            error,
        });
    }
    static fromV2Message(message, content, // eslint-disable-line @typescript-eslint/no-explicit-any
    contentType, contentTopic, contentBytes, conversation, senderAddress, error) {
        const { id, sent } = message;
        return new DecodedMessage({
            id,
            messageVersion: 'v2',
            senderAddress,
            sent,
            content,
            contentBytes,
            contentType,
            contentTopic,
            conversation,
            error,
        });
    }
}
export async function decodeContent(contentBytes, client) {
    const encodedContent = protoContent.EncodedContent.decode(contentBytes);
    if (!encodedContent.type) {
        throw new Error('missing content type');
    }
    let content; // eslint-disable-line @typescript-eslint/no-explicit-any
    let contentType = new ContentTypeId(encodedContent.type);
    let error;
    await decompress(encodedContent, 1000);
    const codec = client.codecFor(contentType);
    if (codec) {
        content = codec.decode(encodedContent, client);
    }
    else {
        error = new Error('unknown content type ' + contentType);
        if (encodedContent.fallback) {
            content = encodedContent.fallback;
            contentType = ContentTypeFallback;
        }
    }
    return { content, contentType, error };
}
function conversationReferenceToConversation(reference, client, version) {
    if (version === 'v1') {
        return new ConversationV1(client, reference.peerAddress, nsToDate(reference.createdNs));
    }
    if (version === 'v2') {
        return new ConversationV2(client, reference.topic, reference.peerAddress, nsToDate(reference.createdNs), reference.context);
    }
    throw new Error(`Unknown conversation version ${version}`);
}
//# sourceMappingURL=Message.js.map