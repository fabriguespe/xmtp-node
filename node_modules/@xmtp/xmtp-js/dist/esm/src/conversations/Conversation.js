import { buildUserIntroTopic, buildDirectMessageTopic, dateToNs, concat, b64Decode, toNanoString, } from '../utils';
import { utils } from 'ethers';
import Stream from '../Stream';
import { DecodedMessage, MessageV1, MessageV2, decodeContent } from '../Message';
import { message, content as proto, } from '@xmtp/proto';
import { SignedPublicKey, Signature, PublicKeyBundle, SignedPublicKeyBundle, } from '../crypto';
import { PreparedMessage } from '../PreparedMessage';
import { sha256 } from '../crypto/encryption';
import { buildDecryptV1Request, getResultOrThrow } from '../utils/keystore';
import { ContentTypeText } from '../codecs/Text';
/**
 * ConversationV1 allows you to view, stream, and send messages to/from a peer address
 */
export class ConversationV1 {
    constructor(client, address, createdAt) {
        this.context = undefined;
        this.peerAddress = utils.getAddress(address);
        this.client = client;
        this.createdAt = createdAt;
    }
    get clientAddress() {
        return this.client.address;
    }
    get topic() {
        return buildDirectMessageTopic(this.peerAddress, this.client.address);
    }
    get ephemeralTopic() {
        return buildDirectMessageTopic(this.peerAddress, this.client.address).replace('/xmtp/0/dm-', '/xmtp/0/dmE-');
    }
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    async messages(opts) {
        const topic = buildDirectMessageTopic(this.peerAddress, this.client.address);
        const messages = await this.client.listEnvelopes(topic, this.processEnvelope.bind(this), opts);
        return this.decryptBatch(messages, topic, false);
    }
    messagesPaginated(opts) {
        return this.client.listEnvelopesPaginated(this.topic, 
        // This won't be performant once we start supporting a remote keystore
        // TODO: Either better batch support or we ditch this under-utilized feature
        this.decodeMessage.bind(this), opts);
    }
    // decodeMessage takes an envelope and either returns a `DecodedMessage` or throws if an error occurs
    async decodeMessage(env) {
        if (!env.contentTopic) {
            throw new Error('Missing content topic');
        }
        const msg = await this.processEnvelope(env);
        const decryptResults = await this.decryptBatch([msg], env.contentTopic, true);
        if (!decryptResults.length) {
            throw new Error('No results');
        }
        return decryptResults[0];
    }
    async prepareMessage(content, // eslint-disable-line @typescript-eslint/no-explicit-any
    options) {
        let topics;
        let recipient = await this.client.getUserContact(this.peerAddress);
        if (!recipient) {
            throw new Error(`recipient ${this.peerAddress} is not registered`);
        }
        if (!(recipient instanceof PublicKeyBundle)) {
            recipient = recipient.toLegacyBundle();
        }
        if (!this.client.contacts.has(this.peerAddress)) {
            topics = [
                buildUserIntroTopic(this.peerAddress),
                buildUserIntroTopic(this.client.address),
                this.topic,
            ];
            this.client.contacts.add(this.peerAddress);
        }
        else {
            topics = [this.topic];
        }
        const payload = await this.client.encodeContent(content, options);
        const msg = await this.createMessage(payload, recipient, options?.timestamp);
        const env = {
            contentTopic: this.topic,
            message: msg.toBytes(),
            timestampNs: toNanoString(msg.sent),
        };
        return new PreparedMessage(env, async () => {
            await this.client.publishEnvelopes(topics.map((topic) => ({
                contentTopic: topic,
                message: msg.toBytes(),
                timestamp: msg.sent,
            })));
        });
    }
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages() {
        return Stream.create(this.client, [this.topic], async (env) => this.decodeMessage(env));
    }
    async processEnvelope({ message, contentTopic, }) {
        const messageBytes = b64Decode(message);
        const decoded = await MessageV1.fromBytes(messageBytes);
        const { senderAddress, recipientAddress } = decoded;
        // Filter for topics
        if (!senderAddress ||
            !recipientAddress ||
            !contentTopic ||
            buildDirectMessageTopic(senderAddress, recipientAddress) !== this.topic) {
            throw new Error('Headers do not match intended recipient');
        }
        return decoded;
    }
    streamEphemeral() {
        return Stream.create(this.client, [this.ephemeralTopic], this.decodeMessage.bind(this));
    }
    /**
     * Send a message into the conversation.
     */
    async send(content, // eslint-disable-line @typescript-eslint/no-explicit-any
    options) {
        let topics;
        let recipient = await this.client.getUserContact(this.peerAddress);
        if (!recipient) {
            throw new Error(`recipient ${this.peerAddress} is not registered`);
        }
        if (!(recipient instanceof PublicKeyBundle)) {
            recipient = recipient.toLegacyBundle();
        }
        const topic = options?.ephemeral ? this.ephemeralTopic : this.topic;
        if (!this.client.contacts.has(this.peerAddress)) {
            topics = [
                buildUserIntroTopic(this.peerAddress),
                buildUserIntroTopic(this.client.address),
                topic,
            ];
            this.client.contacts.add(this.peerAddress);
        }
        else {
            topics = [this.topic];
        }
        const contentType = options?.contentType || ContentTypeText;
        const payload = await this.client.encodeContent(content, options);
        const msg = await this.createMessage(payload, recipient, options?.timestamp);
        await this.client.publishEnvelopes(topics.map((topic) => ({
            contentTopic: topic,
            message: msg.toBytes(),
            timestamp: msg.sent,
        })));
        return DecodedMessage.fromV1Message(msg, content, contentType, payload, topics[0], // Just use the first topic for the returned value
        this);
    }
    async decryptBatch(messages, topic, throwOnError = false) {
        const responses = (await this.client.keystore.decryptV1(buildDecryptV1Request(messages, this.client.publicKeyBundle))).responses;
        const out = [];
        for (let i = 0; i < responses.length; i++) {
            const result = responses[i];
            const message = messages[i];
            try {
                const { decrypted } = getResultOrThrow(result);
                out.push(await this.buildDecodedMessage(message, decrypted, topic));
            }
            catch (e) {
                if (throwOnError) {
                    throw e;
                }
                console.warn('Error decoding content', e);
            }
        }
        return out;
    }
    async buildDecodedMessage(message, decrypted, topic) {
        const { content, contentType, error } = await decodeContent(decrypted, this.client);
        return DecodedMessage.fromV1Message(message, content, contentType, decrypted, topic, this, error);
    }
    async createMessage(
    // Payload is expected to be the output of `client.encodeContent`
    payload, recipient, timestamp) {
        timestamp = timestamp || new Date();
        return MessageV1.encode(this.client.keystore, payload, this.client.publicKeyBundle, recipient, timestamp);
    }
}
/**
 * ConversationV2
 */
export class ConversationV2 {
    constructor(client, topic, peerAddress, createdAt, context) {
        this.topic = topic;
        this.createdAt = createdAt;
        this.context = context;
        this.client = client;
        this.peerAddress = peerAddress;
    }
    get clientAddress() {
        return this.client.address;
    }
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    async messages(opts) {
        const messages = await this.client.listEnvelopes(this.topic, this.processEnvelope.bind(this), opts);
        return this.decryptBatch(messages, false);
    }
    messagesPaginated(opts) {
        return this.client.listEnvelopesPaginated(this.topic, this.decodeMessage.bind(this), opts);
    }
    get ephemeralTopic() {
        return this.topic.replace('/xmtp/0/m', '/xmtp/0/mE');
    }
    streamEphemeral() {
        return Stream.create(this.client, [this.ephemeralTopic], this.decodeMessage.bind(this));
    }
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages() {
        return Stream.create(this.client, [this.topic], this.decodeMessage.bind(this));
    }
    /**
     * Send a message into the conversation
     */
    async send(content, // eslint-disable-line @typescript-eslint/no-explicit-any
    options) {
        const payload = await this.client.encodeContent(content, options);
        const msg = await this.createMessage(payload, options?.timestamp);
        let topic;
        if (options?.ephemeral) {
            topic = this.ephemeralTopic;
        }
        else {
            topic = this.topic;
        }
        await this.client.publishEnvelopes([
            {
                contentTopic: topic,
                message: msg.toBytes(),
                timestamp: msg.sent,
            },
        ]);
        const contentType = options?.contentType || ContentTypeText;
        return DecodedMessage.fromV2Message(msg, content, contentType, this.topic, payload, this, this.client.address);
    }
    async createMessage(
    // Payload is expected to have already gone through `client.encodeContent`
    payload, timestamp) {
        const header = {
            topic: this.topic,
            createdNs: dateToNs(timestamp || new Date()),
        };
        const headerBytes = message.MessageHeaderV2.encode(header).finish();
        const digest = await sha256(concat(headerBytes, payload));
        const signed = {
            payload,
            sender: this.client.signedPublicKeyBundle,
            signature: await this.client.keystore.signDigest({
                digest,
                prekeyIndex: 0,
                identityKey: undefined,
            }),
        };
        const signedBytes = proto.SignedContent.encode(signed).finish();
        const ciphertext = await this.encryptMessage(signedBytes, headerBytes);
        const protoMsg = {
            v1: undefined,
            v2: { headerBytes, ciphertext },
        };
        const bytes = message.Message.encode(protoMsg).finish();
        return MessageV2.create(protoMsg, header, bytes);
    }
    async decryptBatch(messages, throwOnError = false) {
        const responses = (await this.client.keystore.decryptV2(this.buildDecryptRequest(messages))).responses;
        const out = [];
        for (let i = 0; i < responses.length; i++) {
            const result = responses[i];
            const message = messages[i];
            try {
                const { decrypted } = getResultOrThrow(result);
                out.push(await this.buildDecodedMessage(message, decrypted));
            }
            catch (e) {
                if (throwOnError) {
                    throw e;
                }
                console.warn('Error decoding content', e);
            }
        }
        return out;
    }
    buildDecryptRequest(messages) {
        return {
            requests: messages.map((m) => {
                return {
                    payload: m.ciphertext,
                    headerBytes: m.headerBytes,
                    contentTopic: this.topic,
                };
            }),
        };
    }
    async encryptMessage(payload, headerBytes) {
        const { responses } = await this.client.keystore.encryptV2({
            requests: [
                {
                    payload,
                    headerBytes,
                    contentTopic: this.topic,
                },
            ],
        });
        if (responses.length !== 1) {
            throw new Error('Invalid response length');
        }
        const { encrypted } = getResultOrThrow(responses[0]);
        return encrypted;
    }
    async buildDecodedMessage(msg, decrypted) {
        // Decode the decrypted bytes into SignedContent
        const signed = proto.SignedContent.decode(decrypted);
        if (!signed.sender?.identityKey ||
            !signed.sender?.preKey ||
            !signed.signature) {
            throw new Error('incomplete signed content');
        }
        await validatePrekeys(signed);
        // Verify the signature
        const digest = await sha256(concat(msg.headerBytes, signed.payload));
        if (!new SignedPublicKey(signed.sender?.preKey).verify(new Signature(signed.signature), digest)) {
            throw new Error('invalid signature');
        }
        // Derive the sender address from the valid signature
        const senderAddress = await new SignedPublicKeyBundle(signed.sender).walletSignatureAddress();
        const { content, contentType, error } = await decodeContent(signed.payload, this.client);
        return DecodedMessage.fromV2Message(msg, content, contentType, this.topic, signed.payload, this, senderAddress, error);
    }
    async prepareMessage(content, // eslint-disable-line @typescript-eslint/no-explicit-any
    options) {
        const payload = await this.client.encodeContent(content, options);
        const msg = await this.createMessage(payload, options?.timestamp);
        const topic = options?.ephemeral ? this.ephemeralTopic : this.topic;
        const env = {
            contentTopic: topic,
            message: msg.toBytes(),
            timestampNs: toNanoString(msg.sent),
        };
        return new PreparedMessage(env, async () => {
            await this.client.publishEnvelopes([
                {
                    contentTopic: this.topic,
                    message: msg.toBytes(),
                    timestamp: msg.sent,
                },
            ]);
        });
    }
    async processEnvelope(env) {
        if (!env.message || !env.contentTopic) {
            throw new Error('empty envelope');
        }
        const messageBytes = b64Decode(env.message.toString());
        const msg = message.Message.decode(messageBytes);
        if (!msg.v2) {
            throw new Error('unknown message version');
        }
        const header = message.MessageHeaderV2.decode(msg.v2.headerBytes);
        if (header.topic !== this.topic) {
            throw new Error('topic mismatch');
        }
        return MessageV2.create(msg, header, messageBytes);
    }
    async decodeMessage(env) {
        if (!env.contentTopic) {
            throw new Error('Missing content topic');
        }
        const msg = await this.processEnvelope(env);
        const decryptResults = await this.decryptBatch([msg], true);
        if (!decryptResults.length) {
            throw new Error('No results');
        }
        return decryptResults[0];
    }
}
async function validatePrekeys(signed) {
    // Check that the pre key is signed by the identity key
    // this is required to chain the prekey-signed message to the identity key
    // and finally to the user's wallet address
    const senderPreKey = signed.sender?.preKey;
    if (!senderPreKey || !senderPreKey.signature || !senderPreKey.keyBytes) {
        throw new Error('missing pre-key or pre-key signature');
    }
    const senderIdentityKey = signed.sender?.identityKey;
    if (!senderIdentityKey) {
        throw new Error('missing identity key in bundle');
    }
    const isValidPrekey = await new SignedPublicKey(senderIdentityKey).verifyKey(new SignedPublicKey(senderPreKey));
    if (!isValidPrekey) {
        throw new Error('pre key not signed by identity key');
    }
}
//# sourceMappingURL=Conversation.js.map