export const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
export const promiseWithTimeout = (timeoutMs, promise, failureMessage) => {
    let timeoutHandle;
    const timeoutPromise = new Promise((_resolve, reject) => {
        timeoutHandle = setTimeout(() => reject(new Error(failureMessage)), timeoutMs);
    });
    return Promise.race([promise(), timeoutPromise]).then((result) => {
        clearTimeout(timeoutHandle);
        return result;
    });
};
const defaultIsRetryableFn = (err) => !!err;
// Implements type safe retries of arbitrary async functions
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function retry(fn, args, maxRetries, sleepTime, isRetryableFn = defaultIsRetryableFn, retryCount = 1) {
    const currRetry = typeof retryCount === 'number' ? retryCount : 1;
    try {
        const result = await fn(...args);
        return result;
    }
    catch (e) {
        if (!isRetryableFn(e) || currRetry > maxRetries) {
            throw e;
        }
        await sleep(sleepTime);
        return retry(fn, args, maxRetries, sleepTime, isRetryableFn, currRetry + 1);
    }
}
// Takes an async generator returning pages of envelopes and converts to an async
// generator returning pages of an arbitrary type using a mapper function
export async function* mapPaginatedStream(gen, mapper) {
    for await (const page of gen) {
        const results = await Promise.allSettled(page.map(mapper));
        const out = [];
        for (const result of results) {
            if (result.status === 'fulfilled') {
                out.push(result.value);
            }
            else {
                console.warn('Failed to process envelope due to reason: ', result.reason);
            }
        }
        yield out;
    }
}
//# sourceMappingURL=async.js.map