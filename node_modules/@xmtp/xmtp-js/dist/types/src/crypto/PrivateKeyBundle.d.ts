import { privateKey as proto } from '@xmtp/proto';
import { PrivateKey, SignedPrivateKey } from './PrivateKey';
import { PublicKey, SignedPublicKey } from './PublicKey';
import { PublicKeyBundle, SignedPublicKeyBundle } from './PublicKeyBundle';
import { Signer } from '../types/Signer';
export declare class PrivateKeyBundleV2 implements proto.PrivateKeyBundleV2 {
    identityKey: SignedPrivateKey;
    preKeys: SignedPrivateKey[];
    version: number;
    private _publicKeyBundle?;
    constructor(bundle: proto.PrivateKeyBundleV2);
    static generate(wallet: Signer): Promise<PrivateKeyBundleV2>;
    getCurrentPreKey(): SignedPrivateKey;
    findPreKey(which: SignedPublicKey): SignedPrivateKey;
    addPreKey(): Promise<void>;
    getPublicKeyBundle(): SignedPublicKeyBundle;
    sharedSecret(peer: SignedPublicKeyBundle, myPreKey: SignedPublicKey, isRecipient: boolean): Promise<Uint8Array>;
    encode(): Uint8Array;
    equals(other: this): boolean;
    static fromLegacyBundle(bundle: PrivateKeyBundleV1): PrivateKeyBundleV2;
}
export declare class PrivateKeyBundleV1 implements proto.PrivateKeyBundleV1 {
    identityKey: PrivateKey;
    preKeys: PrivateKey[];
    version: number;
    private _publicKeyBundle?;
    constructor(bundle: proto.PrivateKeyBundleV1);
    static generate(wallet?: Signer): Promise<PrivateKeyBundleV1>;
    getCurrentPreKey(): PrivateKey;
    findPreKey(which: PublicKey): PrivateKey;
    addPreKey(): Promise<void>;
    getPublicKeyBundle(): PublicKeyBundle;
    sharedSecret(peer: PublicKeyBundle | SignedPublicKeyBundle, myPreKey: PublicKey, isRecipient: boolean): Promise<Uint8Array>;
    encode(): Uint8Array;
}
export declare type PrivateKeyBundle = PrivateKeyBundleV1 | PrivateKeyBundleV2;
export declare function decodePrivateKeyBundle(bytes: Uint8Array): PrivateKeyBundle;
