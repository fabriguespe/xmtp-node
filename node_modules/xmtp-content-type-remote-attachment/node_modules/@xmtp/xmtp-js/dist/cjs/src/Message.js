"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeContent = exports.DecodedMessage = exports.MessageV2 = exports.MessageV1 = void 0;
const proto_1 = require("@xmtp/proto");
const long_1 = __importDefault(require("long"));
const Ciphertext_1 = __importDefault(require("./crypto/Ciphertext"));
const crypto_1 = require("./crypto");
const utils_1 = require("./crypto/utils");
const encryption_1 = require("./crypto/encryption");
const MessageContent_1 = require("./MessageContent");
const utils_2 = require("./utils");
const Compression_1 = require("./Compression");
const headerBytesAndCiphertext = (msg) => {
    var _a, _b;
    if ((_a = msg.v1) === null || _a === void 0 ? void 0 : _a.ciphertext) {
        return [msg.v1.headerBytes, new Ciphertext_1.default(msg.v1.ciphertext)];
    }
    if ((_b = msg.v2) === null || _b === void 0 ? void 0 : _b.ciphertext) {
        return [msg.v2.headerBytes, new Ciphertext_1.default(msg.v2.ciphertext)];
    }
    throw new Error('unknown message version');
};
// Message is basic unit of communication on the network.
// Message timestamp is set by the sender.
class MessageBase {
    constructor(id, bytes, obj) {
        ;
        [this.headerBytes, this.ciphertext] = headerBytesAndCiphertext(obj);
        this.id = id;
        this.bytes = bytes;
    }
    toBytes() {
        return this.bytes;
    }
}
// Message header carries the sender and recipient keys used to protect message.
// Message timestamp is set by the sender.
class MessageV1 extends MessageBase {
    constructor(id, bytes, obj, header, senderAddress) {
        super(id, bytes, obj);
        this.conversation = undefined;
        this.senderAddress = senderAddress;
        this.header = header;
    }
    static create(obj, header, bytes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!header.sender) {
                throw new Error('missing message sender');
            }
            const senderAddress = new crypto_1.PublicKeyBundle(header.sender).walletSignatureAddress();
            const id = (0, utils_1.bytesToHex)(yield (0, encryption_1.sha256)(bytes));
            return new MessageV1(id, bytes, obj, header, senderAddress);
        });
    }
    get sent() {
        return new Date(this.header.timestamp.toNumber());
    }
    // wallet address derived from the signature of the message recipient
    get recipientAddress() {
        var _a, _b;
        if (!((_b = (_a = this.header) === null || _a === void 0 ? void 0 : _a.recipient) === null || _b === void 0 ? void 0 : _b.identityKey)) {
            return undefined;
        }
        return new crypto_1.PublicKey(this.header.recipient.identityKey).walletSignatureAddress();
    }
    // encrypt and serialize the message
    static encode(sender, recipient, message, timestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            const secret = yield sender.sharedSecret(recipient, sender.getCurrentPreKey().publicKey, false);
            // eslint-disable-next-line camelcase
            const header = {
                sender: sender.getPublicKeyBundle(),
                recipient,
                timestamp: long_1.default.fromNumber(timestamp.getTime()),
            };
            const headerBytes = proto_1.message.MessageHeaderV1.encode(header).finish();
            const ciphertext = yield (0, crypto_1.encrypt)(message, secret, headerBytes);
            const protoMsg = {
                v1: { headerBytes, ciphertext },
                v2: undefined,
            };
            const bytes = proto_1.message.Message.encode(protoMsg).finish();
            return MessageV1.create(protoMsg, header, bytes);
        });
    }
    static fromBytes(bytes) {
        const message = proto_1.message.Message.decode(bytes);
        const [headerBytes] = headerBytesAndCiphertext(message);
        const header = proto_1.message.MessageHeaderV1.decode(headerBytes);
        if (!header) {
            throw new Error('missing message header');
        }
        if (!header.sender) {
            throw new Error('missing message sender');
        }
        if (!header.sender.identityKey) {
            throw new Error('missing message sender identity key');
        }
        if (!header.sender.preKey) {
            throw new Error('missing message sender pre-key');
        }
        if (!header.recipient) {
            throw new Error('missing message recipient');
        }
        if (!header.recipient.identityKey) {
            throw new Error('missing message recipient identity-key');
        }
        if (!header.recipient.preKey) {
            throw new Error('missing message recipient pre-key');
        }
        return MessageV1.create(message, header, bytes);
    }
    decrypt(viewer) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const header = this.header;
            // This should never happen if the message was created through the fromBytes function
            // But needed for type safety
            if (!((_a = header.recipient) === null || _a === void 0 ? void 0 : _a.identityKey) ||
                !((_b = header.sender) === null || _b === void 0 ? void 0 : _b.identityKey) ||
                !header.recipient.preKey ||
                !header.sender.preKey) {
                throw new Error('Missing headers');
            }
            const recipient = new crypto_1.PublicKeyBundle({
                identityKey: new crypto_1.PublicKey(header.recipient.identityKey),
                preKey: new crypto_1.PublicKey(header.recipient.preKey),
            });
            const sender = new crypto_1.PublicKeyBundle({
                identityKey: new crypto_1.PublicKey(header.sender.identityKey),
                preKey: new crypto_1.PublicKey(header.sender.preKey),
            });
            let secret;
            if (viewer.identityKey.matches(sender.identityKey)) {
                // viewer is the sender
                secret = yield viewer.sharedSecret(recipient, sender.preKey, false);
            }
            else {
                // viewer is the recipient
                secret = yield viewer.sharedSecret(sender, recipient.preKey, true);
            }
            return (0, crypto_1.decrypt)(this.ciphertext, secret, this.headerBytes);
        });
    }
}
exports.MessageV1 = MessageV1;
class MessageV2 extends MessageBase {
    constructor(id, bytes, obj, header, signed, 
    // wallet address derived from the signature of the message sender
    senderAddress) {
        super(id, bytes, obj);
        this.header = header;
        this.signed = signed;
        this.senderAddress = senderAddress;
    }
    static create(obj, header, signed, bytes) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = (0, utils_1.bytesToHex)(yield (0, encryption_1.sha256)(bytes));
            if (!signed.sender) {
                throw new Error('missing message sender');
            }
            const senderAddress = yield new crypto_1.SignedPublicKeyBundle(signed.sender).walletSignatureAddress();
            return new MessageV2(id, bytes, obj, header, signed, senderAddress);
        });
    }
    get sent() {
        return (0, utils_2.nsToDate)(this.header.createdNs);
    }
}
exports.MessageV2 = MessageV2;
class DecodedMessage {
    constructor({ id, messageVersion, senderAddress, recipientAddress, conversation, contentType, contentTopic, content, sent, error, }) {
        this.id = id;
        this.messageVersion = messageVersion;
        this.senderAddress = senderAddress;
        this.recipientAddress = recipientAddress;
        this.conversation = conversation;
        this.contentType = contentType;
        this.sent = sent;
        this.error = error;
        this.content = content;
        this.contentTopic = contentTopic;
    }
    static fromV1Message(message, content, // eslint-disable-line @typescript-eslint/no-explicit-any
    contentType, contentTopic, conversation, error) {
        const { id, senderAddress, recipientAddress, sent } = message;
        if (!senderAddress) {
            throw new Error('Sender address is required');
        }
        return new DecodedMessage({
            id,
            messageVersion: 'v1',
            senderAddress,
            recipientAddress,
            sent,
            content,
            contentType,
            contentTopic,
            conversation,
            error,
        });
    }
    static fromV2Message(message, content, // eslint-disable-line @typescript-eslint/no-explicit-any
    contentType, contentTopic, conversation, error) {
        const { id, senderAddress, sent } = message;
        if (!senderAddress) {
            throw new Error('Sender address is required');
        }
        return new DecodedMessage({
            id,
            messageVersion: 'v2',
            senderAddress,
            sent,
            content,
            contentType,
            contentTopic,
            conversation,
            error,
        });
    }
}
exports.DecodedMessage = DecodedMessage;
function decodeContent(contentBytes, client) {
    return __awaiter(this, void 0, void 0, function* () {
        const encodedContent = proto_1.content.EncodedContent.decode(contentBytes);
        if (!encodedContent.type) {
            throw new Error('missing content type');
        }
        let content; // eslint-disable-line @typescript-eslint/no-explicit-any
        let contentType = new MessageContent_1.ContentTypeId(encodedContent.type);
        let error;
        yield (0, Compression_1.decompress)(encodedContent, 1000);
        const codec = client.codecFor(contentType);
        if (codec) {
            content = codec.decode(encodedContent, client);
        }
        else {
            error = new Error('unknown content type ' + contentType);
            if (encodedContent.fallback) {
                content = encodedContent.fallback;
                contentType = MessageContent_1.ContentTypeFallback;
            }
        }
        return { content, contentType, error };
    });
}
exports.decodeContent = decodeContent;
//# sourceMappingURL=Message.js.map