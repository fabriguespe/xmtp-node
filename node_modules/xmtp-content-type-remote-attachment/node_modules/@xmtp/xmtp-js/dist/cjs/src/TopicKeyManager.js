"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DuplicateTopicError = exports.EncryptionAlgorithm = void 0;
var EncryptionAlgorithm;
(function (EncryptionAlgorithm) {
    EncryptionAlgorithm[EncryptionAlgorithm["AES_256_GCM_HKDF_SHA_256"] = 0] = "AES_256_GCM_HKDF_SHA_256";
})(EncryptionAlgorithm = exports.EncryptionAlgorithm || (exports.EncryptionAlgorithm = {}));
/**
 * Custom error type for cases where the caller attempted to add a second key to the same topic
 */
class DuplicateTopicError extends Error {
    constructor(topic) {
        super(`Topic ${topic} has already been added`);
        this.name = 'DuplicateTopicError';
        Object.setPrototypeOf(this, DuplicateTopicError.prototype);
    }
}
exports.DuplicateTopicError = DuplicateTopicError;
const findLatestTopic = (records) => {
    let latestRecord;
    for (const record of records) {
        if (!latestRecord || record.createdAt > latestRecord.createdAt) {
            latestRecord = record;
        }
    }
    if (!latestRecord) {
        throw new Error('No record found');
    }
    return latestRecord;
};
/**
 * TopicKeyManager stores the mapping between topics -> keys and wallet addresses -> keys
 */
class TopicKeyManager {
    constructor() {
        this.topicKeys = new Map();
        this.dmTopics = new Map();
    }
    /**
     * Create a TopicKeyRecord for the topic and store it for later access
     *
     * @param contentTopic The topic
     * @param key TopicKeyRecord that contains the topic key and encryption algorithm
     * @param counterparty The other user's PublicKeyBundle
     * @param createdAt Date
     */
    addDirectMessageTopic(contentTopic, key, counterparty, createdAt) {
        if (this.topicKeys.has(contentTopic)) {
            throw new DuplicateTopicError(contentTopic);
        }
        this.topicKeys.set(contentTopic, key);
        const walletAddress = counterparty.identityKey.walletSignatureAddress();
        const counterpartyTopicList = this.dmTopics.get(walletAddress) || [];
        counterpartyTopicList.push({ contentTopic, createdAt });
        this.dmTopics.set(walletAddress, counterpartyTopicList);
    }
    /**
     * Would be used to get all information required to decrypt/validate a given message
     */
    getByTopic(contentTopic) {
        const topicKey = this.topicKeys.get(contentTopic);
        if (!topicKey) {
            return undefined;
        }
        return {
            topicKey,
            contentTopic,
        };
    }
    /**
     *  Used to know which topic/key to use to send to a given wallet address
     */
    getLatestByWalletAddress(walletAddress) {
        const walletTopics = this.dmTopics.get(walletAddress);
        if (!walletTopics || !walletTopics.length) {
            return undefined;
        }
        const newestTopic = findLatestTopic(walletTopics);
        return this.getByTopic(newestTopic.contentTopic);
    }
    /**
     * Used to get the topic list to listen for all messages from a given wallet address
     */
    getAllByWalletAddress(walletAddress) {
        var _a;
        const dmTopics = (_a = this.dmTopics
            .get(walletAddress)) === null || _a === void 0 ? void 0 : _a.map(({ contentTopic }) => this.getByTopic(contentTopic)).filter((res) => !!res);
        return dmTopics || [];
    }
}
exports.default = TopicKeyManager;
//# sourceMappingURL=TopicKeyManager.js.map