"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationV2 = exports.ConversationV1 = void 0;
const utils_1 = require("../utils");
const ethers_1 = require("ethers");
const Message_1 = require("./../Message");
const Stream_1 = __importDefault(require("../Stream"));
const Message_2 = require("../Message");
const proto_1 = require("@xmtp/proto");
const crypto_1 = require("../crypto");
const PreparedMessage_1 = require("../PreparedMessage");
const Ciphertext_1 = __importDefault(require("../crypto/Ciphertext"));
const encryption_1 = require("../crypto/encryption");
const Text_1 = require("../codecs/Text");
const keystore_1 = require("../keystore");
const long_1 = __importDefault(require("long"));
const { b64Decode } = proto_1.fetcher;
/**
 * Conversation class allows you to view, stream, and send messages to/from a peer address
 */
class ConversationV1 {
    constructor(client, address, createdAt) {
        this.context = null;
        this.peerAddress = ethers_1.utils.getAddress(address);
        this.client = client;
        this.createdAt = createdAt;
    }
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const topic = (0, utils_1.buildDirectMessageTopic)(this.peerAddress, this.client.address);
            const messages = yield this.client.listEnvelopes([topic], this.decodeEnvelope.bind(this), opts);
            return this.decryptBatch(messages, topic, false);
        });
    }
    decryptBatch(messages, topic, throwOnError = false) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const responses = (yield this.client.keystore.decryptV1(this.buildDecryptRequest(messages))).responses;
            const out = [];
            for (let i = 0; i < responses.length; i++) {
                const result = responses[i];
                const message = messages[i];
                if (result.error) {
                    console.warn('Error decrypting message', result.error);
                    if (throwOnError) {
                        throw new keystore_1.KeystoreError((_a = result.error) === null || _a === void 0 ? void 0 : _a.code, (_b = result.error) === null || _b === void 0 ? void 0 : _b.message);
                    }
                    continue;
                }
                if (!((_c = result.result) === null || _c === void 0 ? void 0 : _c.decrypted)) {
                    console.warn('Error decrypting message', result);
                    if (throwOnError) {
                        throw new keystore_1.KeystoreError(proto_1.keystore.ErrorCode.ERROR_CODE_UNSPECIFIED, 'No result returned');
                    }
                    continue;
                }
                try {
                    out.push(yield this.buildDecodedMessage(message, result.result.decrypted, topic));
                }
                catch (e) {
                    console.warn('Error decoding content', e);
                    if (throwOnError) {
                        throw e;
                    }
                }
            }
            return out;
        });
    }
    buildDecryptRequest(messages) {
        return {
            requests: messages.map((m) => {
                var _a, _b, _c, _d;
                const sender = new crypto_1.PublicKeyBundle({
                    identityKey: (_a = m.header.sender) === null || _a === void 0 ? void 0 : _a.identityKey,
                    preKey: (_b = m.header.sender) === null || _b === void 0 ? void 0 : _b.preKey,
                });
                const isSender = this.client.publicKeyBundle.equals(sender);
                return {
                    payload: m.ciphertext,
                    peerKeys: isSender
                        ? new crypto_1.PublicKeyBundle({
                            identityKey: (_c = m.header.recipient) === null || _c === void 0 ? void 0 : _c.identityKey,
                            preKey: (_d = m.header.recipient) === null || _d === void 0 ? void 0 : _d.preKey,
                        })
                        : sender,
                    headerBytes: m.headerBytes,
                    isSender,
                };
            }),
        };
    }
    buildDecodedMessage(message, decrypted, topic) {
        return __awaiter(this, void 0, void 0, function* () {
            const { content, contentType, error } = yield (0, Message_2.decodeContent)(decrypted, this.client);
            return Message_1.DecodedMessage.fromV1Message(message, content, contentType, topic, this, error);
        });
    }
    messagesPaginated(opts) {
        return this.client.listEnvelopesPaginated([this.topic], 
        // This won't be performant once we start supporting a remote keystore
        // TODO: Either better batch support or we ditch this under-utilized feature
        this.decodeMessage.bind(this), opts);
    }
    // decodeMessage takes an envelope and either returns a `DecodedMessage` or throws if an error occurs
    decodeMessage(env) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!env.contentTopic) {
                throw new Error('Missing content topic');
            }
            const msg = yield this.decodeEnvelope(env);
            const decryptResults = yield this.decryptBatch([msg], env.contentTopic, true);
            if (!decryptResults.length) {
                throw new Error('No results');
            }
            return decryptResults[0];
        });
    }
    get topic() {
        return (0, utils_1.buildDirectMessageTopic)(this.peerAddress, this.client.address);
    }
    prepareMessage(content, // eslint-disable-line @typescript-eslint/no-explicit-any
    options) {
        return __awaiter(this, void 0, void 0, function* () {
            let topics;
            let recipient = yield this.client.getUserContact(this.peerAddress);
            if (!recipient) {
                throw new Error(`recipient ${this.peerAddress} is not registered`);
            }
            if (!(recipient instanceof crypto_1.PublicKeyBundle)) {
                recipient = recipient.toLegacyBundle();
            }
            if (!this.client.contacts.has(this.peerAddress)) {
                topics = [
                    (0, utils_1.buildUserIntroTopic)(this.peerAddress),
                    (0, utils_1.buildUserIntroTopic)(this.client.address),
                    this.topic,
                ];
                this.client.contacts.add(this.peerAddress);
            }
            else {
                topics = [this.topic];
            }
            const msg = yield this.encodeMessage(content, recipient, options);
            const env = {
                contentTopic: this.topic,
                message: msg.toBytes(),
                timestampNs: (0, utils_1.toNanoString)(msg.sent),
            };
            return new PreparedMessage_1.PreparedMessage(env, () => __awaiter(this, void 0, void 0, function* () {
                yield this.client.publishEnvelopes(topics.map((topic) => ({
                    contentTopic: topic,
                    message: msg.toBytes(),
                    timestamp: msg.sent,
                })));
            }));
        });
    }
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages() {
        return Stream_1.default.create(this.client, [this.topic], (env) => __awaiter(this, void 0, void 0, function* () { return this.decodeMessage(env); }));
    }
    export() {
        return {
            version: 'v1',
            peerAddress: this.peerAddress,
            createdAt: this.createdAt.toISOString(),
        };
    }
    static fromExport(client, data) {
        return new ConversationV1(client, data.peerAddress, new Date(data.createdAt));
    }
    decodeEnvelope({ message, contentTopic, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const messageBytes = proto_1.fetcher.b64Decode(message);
            const decoded = yield Message_2.MessageV1.fromBytes(messageBytes);
            const { senderAddress, recipientAddress } = decoded;
            // Filter for topics
            if (!senderAddress ||
                !recipientAddress ||
                !contentTopic ||
                (0, utils_1.buildDirectMessageTopic)(senderAddress, recipientAddress) !== this.topic) {
                throw new Error('Headers do not match intended recipient');
            }
            return decoded;
        });
    }
    /**
     * Send a message into the conversation
     */
    send(content, // eslint-disable-line @typescript-eslint/no-explicit-any
    options) {
        return __awaiter(this, void 0, void 0, function* () {
            let topics;
            let recipient = yield this.client.getUserContact(this.peerAddress);
            if (!recipient) {
                throw new Error(`recipient ${this.peerAddress} is not registered`);
            }
            if (!(recipient instanceof crypto_1.PublicKeyBundle)) {
                recipient = recipient.toLegacyBundle();
            }
            if (!this.client.contacts.has(this.peerAddress)) {
                topics = [
                    (0, utils_1.buildUserIntroTopic)(this.peerAddress),
                    (0, utils_1.buildUserIntroTopic)(this.client.address),
                    this.topic,
                ];
                this.client.contacts.add(this.peerAddress);
            }
            else {
                topics = [this.topic];
            }
            const contentType = (options === null || options === void 0 ? void 0 : options.contentType) || Text_1.ContentTypeText;
            const msg = yield this.encodeMessage(content, recipient, options);
            yield this.client.publishEnvelopes(topics.map((topic) => ({
                contentTopic: topic,
                message: msg.toBytes(),
                timestamp: msg.sent,
            })));
            return Message_1.DecodedMessage.fromV1Message(msg, content, contentType, topics[0], // Just use the first topic for the returned value
            this);
        });
    }
    encodeMessage(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    content, recipient, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const timestamp = (options === null || options === void 0 ? void 0 : options.timestamp) || new Date();
            const payload = yield this.client.encodeContent(content, options);
            const header = {
                sender: this.client.publicKeyBundle,
                recipient,
                timestamp: long_1.default.fromNumber(timestamp.getTime()),
            };
            const headerBytes = proto_1.message.MessageHeaderV1.encode(header).finish();
            const results = yield this.client.keystore.encryptV1({
                requests: [
                    {
                        recipient,
                        headerBytes,
                        payload,
                    },
                ],
            });
            if (!results.responses.length) {
                throw new Error('No response from Keystore');
            }
            const response = results.responses[0];
            this.validateKeystoreResponse(response);
            const ciphertext = (_a = response.result) === null || _a === void 0 ? void 0 : _a.encrypted;
            const protoMsg = {
                v1: { headerBytes, ciphertext },
                v2: undefined,
            };
            const bytes = proto_1.message.Message.encode(protoMsg).finish();
            return Message_2.MessageV1.create(protoMsg, header, bytes);
        });
    }
    validateKeystoreResponse(response) {
        if (response.error) {
            throw new keystore_1.KeystoreError(response.error.code, response.error.message);
        }
        if (!response.result) {
            throw new keystore_1.KeystoreError(proto_1.keystore.ErrorCode.ERROR_CODE_UNSPECIFIED, 'No result from Keystore');
        }
    }
    get clientAddress() {
        return this.client.address;
    }
}
exports.ConversationV1 = ConversationV1;
class ConversationV2 {
    constructor(client, topic, keyMaterial, peerAddress, createdAt, context) {
        this.topic = topic;
        this.keyMaterial = keyMaterial;
        this.createdAt = createdAt;
        this.context = context;
        this.client = client;
        this.peerAddress = peerAddress;
    }
    static create(client, invitation, header) {
        return __awaiter(this, void 0, void 0, function* () {
            const myKeys = client.keys.getPublicKeyBundle();
            const peer = myKeys.equals(header.sender) ? header.recipient : header.sender;
            const peerAddress = ethers_1.utils.getAddress(yield peer.walletSignatureAddress());
            return new ConversationV2(client, invitation.topic, invitation.aes256GcmHkdfSha256.keyMaterial, peerAddress, (0, utils_1.nsToDate)(header.createdNs), invitation.context);
        });
    }
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.listEnvelopes([this.topic], this.decodeMessage.bind(this), opts);
        });
    }
    messagesPaginated(opts) {
        return this.client.listEnvelopesPaginated([this.topic], this.decodeMessage.bind(this), opts);
    }
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages() {
        return Stream_1.default.create(this.client, [this.topic], this.decodeMessage.bind(this));
    }
    /**
     * Send a message into the conversation
     */
    send(content, // eslint-disable-line @typescript-eslint/no-explicit-any
    options) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = yield this.encodeMessage(content, options);
            yield this.client.publishEnvelopes([
                {
                    contentTopic: this.topic,
                    message: msg.toBytes(),
                    timestamp: msg.sent,
                },
            ]);
            const contentType = (options === null || options === void 0 ? void 0 : options.contentType) || Text_1.ContentTypeText;
            return Message_1.DecodedMessage.fromV2Message(msg, content, contentType, this.topic, this);
        });
    }
    get clientAddress() {
        return this.client.address;
    }
    encodeMessage(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    content, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = yield this.client.encodeContent(content, options);
            const header = {
                topic: this.topic,
                createdNs: (0, utils_1.dateToNs)((options === null || options === void 0 ? void 0 : options.timestamp) || new Date()),
            };
            const headerBytes = proto_1.message.MessageHeaderV2.encode(header).finish();
            const digest = yield (0, encryption_1.sha256)(concat(headerBytes, payload));
            const signed = {
                payload,
                sender: this.client.keys.getPublicKeyBundle(),
                signature: yield this.client.keys.getCurrentPreKey().sign(digest),
            };
            const signedBytes = proto_1.content.SignedContent.encode(signed).finish();
            const ciphertext = yield (0, crypto_1.encrypt)(signedBytes, this.keyMaterial, headerBytes);
            const protoMsg = {
                v1: undefined,
                v2: { headerBytes, ciphertext },
            };
            const bytes = proto_1.message.Message.encode(protoMsg).finish();
            return Message_2.MessageV2.create(protoMsg, header, signed, bytes);
        });
    }
    decodeMessage(env) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            if (!env.message || !env.contentTopic) {
                throw new Error('empty envelope');
            }
            const messageBytes = b64Decode(env.message.toString());
            const msg = proto_1.message.Message.decode(messageBytes);
            if (!msg.v2) {
                throw new Error('unknown message version');
            }
            const msgv2 = msg.v2;
            const header = proto_1.message.MessageHeaderV2.decode(msgv2.headerBytes);
            if (header.topic !== this.topic) {
                throw new Error('topic mismatch');
            }
            if (!msgv2.ciphertext) {
                throw new Error('missing ciphertext');
            }
            const decrypted = yield (0, crypto_1.decrypt)(new Ciphertext_1.default(msgv2.ciphertext), this.keyMaterial, msgv2.headerBytes);
            const signed = proto_1.content.SignedContent.decode(decrypted);
            if (!((_a = signed.sender) === null || _a === void 0 ? void 0 : _a.identityKey) ||
                !((_b = signed.sender) === null || _b === void 0 ? void 0 : _b.preKey) ||
                !signed.signature) {
                throw new Error('incomplete signed content');
            }
            // Check that the pre key is signed by the identity key
            // this is required to chain the prekey-signed message to the identity key
            // and finally to the user's wallet address
            const senderPreKey = (_c = signed.sender) === null || _c === void 0 ? void 0 : _c.preKey;
            if (!senderPreKey || !senderPreKey.signature || !senderPreKey.keyBytes) {
                throw new Error('missing pre-key or pre-key signature');
            }
            const senderIdentityKey = (_d = signed.sender) === null || _d === void 0 ? void 0 : _d.identityKey;
            if (!senderIdentityKey) {
                throw new Error('missing identity key in bundle');
            }
            const isValidPrekey = yield new crypto_1.SignedPublicKey(senderIdentityKey).verifyKey(new crypto_1.SignedPublicKey(senderPreKey));
            if (!isValidPrekey) {
                throw new Error('pre key not signed by identity key');
            }
            const digest = yield (0, encryption_1.sha256)(concat(msgv2.headerBytes, signed.payload));
            if (!new crypto_1.SignedPublicKey((_e = signed.sender) === null || _e === void 0 ? void 0 : _e.preKey).verify(new crypto_1.Signature(signed.signature), digest)) {
                throw new Error('invalid signature');
            }
            const messageV2 = yield Message_2.MessageV2.create(msg, header, signed, messageBytes);
            const { content, contentType, error } = yield (0, Message_2.decodeContent)(signed.payload, this.client);
            return Message_1.DecodedMessage.fromV2Message(messageV2, content, contentType, env.contentTopic, this, error);
        });
    }
    prepareMessage(content, // eslint-disable-line @typescript-eslint/no-explicit-any
    options) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = yield this.encodeMessage(content, options);
            const env = {
                contentTopic: this.topic,
                message: msg.toBytes(),
                timestampNs: (0, utils_1.toNanoString)(msg.sent),
            };
            return new PreparedMessage_1.PreparedMessage(env, () => __awaiter(this, void 0, void 0, function* () {
                yield this.client.publishEnvelopes([
                    {
                        contentTopic: this.topic,
                        message: msg.toBytes(),
                        timestamp: msg.sent,
                    },
                ]);
            }));
        });
    }
    export() {
        return {
            version: 'v2',
            topic: this.topic,
            keyMaterial: Buffer.from(this.keyMaterial).toString('base64'),
            peerAddress: this.peerAddress,
            createdAt: this.createdAt.toISOString(),
            context: this.context,
        };
    }
    static fromExport(client, data) {
        return new ConversationV2(client, data.topic, Buffer.from(data.keyMaterial, 'base64'), data.peerAddress, new Date(data.createdAt), data.context);
    }
}
exports.ConversationV2 = ConversationV2;
function concat(a, b) {
    const ab = new Uint8Array(a.length + b.length);
    ab.set(a);
    ab.set(b, a.length);
    return ab;
}
//# sourceMappingURL=Conversation.js.map