"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const proto_1 = require("@xmtp/proto");
const PrivateKeyBundle_1 = require("./../crypto/PrivateKeyBundle");
const Invitation_1 = require("./../Invitation");
const encryption_1 = require("./encryption");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
const utils_2 = require("../utils");
const InviteStore_1 = __importDefault(require("./InviteStore"));
const { ErrorCode } = proto_1.keystore;
class InMemoryKeystore {
    constructor(keys, inviteStore) {
        this.v1Keys = keys;
        this.v2Keys = PrivateKeyBundle_1.PrivateKeyBundleV2.fromLegacyBundle(keys);
        this.inviteStore = inviteStore;
    }
    static create(keys, persistence) {
        return __awaiter(this, void 0, void 0, function* () {
            return new InMemoryKeystore(keys, yield InviteStore_1.default.create(persistence));
        });
    }
    decryptV1(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield (0, utils_1.mapAndConvertErrors)(req.requests, (req) => __awaiter(this, void 0, void 0, function* () {
                if (!(0, utils_1.validateObject)(req, ['payload', 'peerKeys'], ['headerBytes'])) {
                    throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'invalid');
                }
                const { payload, peerKeys, headerBytes, isSender } = req;
                const decrypted = yield (0, encryption_1.decryptV1)(this.v1Keys, (0, utils_1.toPublicKeyBundle)(peerKeys), payload, headerBytes, isSender);
                return {
                    decrypted,
                };
            }), proto_1.keystore.ErrorCode.ERROR_CODE_UNSPECIFIED);
            return proto_1.keystore.DecryptResponse.fromPartial({
                responses,
            });
        });
    }
    decryptV2(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield (0, utils_1.mapAndConvertErrors)(req.requests, (req) => __awaiter(this, void 0, void 0, function* () {
                if (!(0, utils_1.validateObject)(req, ['payload'], ['headerBytes'])) {
                    throw new errors_1.KeystoreError(proto_1.keystore.ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
                }
                const { payload, headerBytes, contentTopic } = req;
                const topicData = this.inviteStore.lookup(contentTopic);
                if (!topicData) {
                    // This is the wrong error type. Will add to the proto repo later
                    throw new errors_1.KeystoreError(proto_1.keystore.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, 'no topic key');
                }
                const decrypted = yield (0, encryption_1.decryptV2)(payload, (0, utils_1.getKeyMaterial)(topicData.invitation), headerBytes);
                return { decrypted };
            }), ErrorCode.ERROR_CODE_UNSPECIFIED);
            return proto_1.keystore.DecryptResponse.fromPartial({
                responses,
            });
        });
    }
    encryptV1(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield (0, utils_1.mapAndConvertErrors)(req.requests, (req) => __awaiter(this, void 0, void 0, function* () {
                if (!(0, utils_1.validateObject)(req, ['payload', 'recipient'], ['headerBytes'])) {
                    throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
                }
                const { recipient, payload, headerBytes } = req;
                return {
                    encrypted: yield (0, encryption_1.encryptV1)(this.v1Keys, (0, utils_1.toPublicKeyBundle)(recipient), payload, headerBytes),
                };
            }), ErrorCode.ERROR_CODE_UNSPECIFIED);
            return proto_1.keystore.EncryptResponse.fromPartial({
                responses,
            });
        });
    }
    encryptV2(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield (0, utils_1.mapAndConvertErrors)(req.requests, (req) => __awaiter(this, void 0, void 0, function* () {
                if (!(0, utils_1.validateObject)(req, ['payload'], ['headerBytes'])) {
                    throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing required field');
                }
                const { payload, headerBytes, contentTopic } = req;
                const topicData = this.inviteStore.lookup(contentTopic);
                if (!topicData) {
                    throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, 'no topic key');
                }
                return {
                    encrypted: yield (0, encryption_1.encryptV2)(payload, (0, utils_1.getKeyMaterial)(topicData.invitation), headerBytes),
                };
            }), ErrorCode.ERROR_CODE_INVALID_INPUT);
            return proto_1.keystore.EncryptResponse.fromPartial({
                responses,
            });
        });
    }
    saveInvites(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const toAdd = [];
            const responses = yield (0, utils_1.mapAndConvertErrors)(req.requests, ({ payload, timestampNs }) => __awaiter(this, void 0, void 0, function* () {
                const sealed = Invitation_1.SealedInvitation.fromBytes(payload);
                const headerTime = sealed.v1.header.createdNs;
                if (!headerTime.equals(timestampNs)) {
                    throw new Error('envelope and header timestamp mismatch');
                }
                const invitation = yield sealed.v1.getInvitation(this.v2Keys);
                const topicData = { invitation, createdNs: sealed.v1.header.createdNs };
                toAdd.push(topicData);
                return {
                    conversation: (0, utils_1.topicDataToConversationReference)(topicData),
                };
            }), ErrorCode.ERROR_CODE_INVALID_INPUT);
            yield this.inviteStore.add(toAdd);
            return proto_1.keystore.SaveInvitesResponse.fromPartial({
                responses,
            });
        });
    }
    createInvite(req) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!(0, utils_1.validateObject)(req, ['recipient'], [])) {
                    throw new errors_1.KeystoreError(ErrorCode.ERROR_CODE_INVALID_INPUT, 'missing recipient');
                }
                const invitation = Invitation_1.InvitationV1.createRandom(req.context);
                const created = (0, utils_2.nsToDate)(req.createdNs);
                const sealed = yield Invitation_1.SealedInvitation.createV1({
                    sender: this.v2Keys,
                    recipient: (0, utils_1.toSignedPublicKeyBundle)(req.recipient),
                    created,
                    invitation,
                });
                const topicData = { invitation, createdNs: req.createdNs };
                yield this.inviteStore.add([topicData]);
                return proto_1.keystore.CreateInviteResponse.fromPartial({
                    conversation: (0, utils_1.topicDataToConversationReference)(topicData),
                    payload: sealed.toBytes(),
                });
            }
            catch (e) {
                throw (0, utils_1.convertError)(e, ErrorCode.ERROR_CODE_INVALID_INPUT);
            }
        });
    }
    getV2Conversations() {
        return __awaiter(this, void 0, void 0, function* () {
            const convos = this.inviteStore.topics.map((invite) => (0, utils_1.topicDataToConversationReference)(invite));
            convos.sort((a, b) => a.createdNs.sub(b.createdNs).toNumber());
            return convos;
        });
    }
    getPublicKeyBundle() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.v2Keys.getPublicKeyBundle();
        });
    }
    getAccountAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.v2Keys.getPublicKeyBundle().walletSignatureAddress();
        });
    }
}
exports.default = InMemoryKeystore;
//# sourceMappingURL=InMemoryKeystore.js.map