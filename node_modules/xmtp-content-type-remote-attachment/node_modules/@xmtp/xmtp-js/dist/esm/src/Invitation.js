var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import Long from 'long';
import { SignedPublicKeyBundle } from './crypto/PublicKeyBundle';
import { invitation, fetcher } from '@xmtp/proto';
import Ciphertext from './crypto/Ciphertext';
import { decrypt, encrypt, utils } from './crypto';
import { dateToNs, buildDirectMessageTopicV2 } from './utils';
const { b64Decode } = fetcher;
/**
 * InvitationV1 is a protobuf message to be encrypted and used as the ciphertext in a SealedInvitationV1 message
 */
export class InvitationV1 {
    constructor({ topic, context, aes256GcmHkdfSha256, }) {
        if (!topic || !topic.length) {
            throw new Error('Missing topic');
        }
        if (!aes256GcmHkdfSha256 ||
            !aes256GcmHkdfSha256.keyMaterial ||
            !aes256GcmHkdfSha256.keyMaterial.length) {
            throw new Error('Missing key material');
        }
        this.topic = topic;
        this.context = context;
        this.aes256GcmHkdfSha256 = aes256GcmHkdfSha256;
    }
    static createRandom(context) {
        const topic = buildDirectMessageTopicV2(Buffer.from(utils.getRandomValues(new Uint8Array(32)))
            .toString('base64')
            .replace(/=*$/g, '')
            // Replace slashes with dashes so that the topic is still easily split by /
            // We do not treat this as needing to be valid Base64 anywhere
            .replace('/', '-'));
        const keyMaterial = utils.getRandomValues(new Uint8Array(32));
        return new InvitationV1({
            topic,
            aes256GcmHkdfSha256: { keyMaterial },
            context,
        });
    }
    toBytes() {
        return invitation.InvitationV1.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new InvitationV1(invitation.InvitationV1.decode(bytes));
    }
}
/**
 * SealedInvitationHeaderV1 is a protobuf message to be used as the headerBytes in a SealedInvitationV1
 */
export class SealedInvitationHeaderV1 {
    constructor({ sender, recipient, createdNs, }) {
        if (!sender) {
            throw new Error('Missing sender');
        }
        if (!recipient) {
            throw new Error('Missing recipient');
        }
        this.sender = new SignedPublicKeyBundle(sender);
        this.recipient = new SignedPublicKeyBundle(recipient);
        this.createdNs = createdNs;
    }
    toBytes() {
        return invitation.SealedInvitationHeaderV1.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new SealedInvitationHeaderV1(invitation.SealedInvitationHeaderV1.decode(bytes));
    }
}
export class SealedInvitationV1 {
    constructor({ headerBytes, ciphertext }) {
        if (!headerBytes || !headerBytes.length) {
            throw new Error('Missing header bytes');
        }
        if (!ciphertext) {
            throw new Error('Missing ciphertext');
        }
        this.headerBytes = headerBytes;
        this.ciphertext = new Ciphertext(ciphertext);
    }
    /**
     * Accessor method for the full header object
     */
    get header() {
        // Use cached value if already exists
        if (this._header) {
            return this._header;
        }
        this._header = SealedInvitationHeaderV1.fromBytes(this.headerBytes);
        return this._header;
    }
    /**
     * getInvitation decrypts and returns the InvitationV1 stored in the ciphertext of the Sealed Invitation
     */
    getInvitation(viewer) {
        return __awaiter(this, void 0, void 0, function* () {
            // Use cached value if already exists
            if (this._invitation) {
                return this._invitation;
            }
            // The constructors for child classes will validate that this is complete
            const header = this.header;
            let secret;
            if (viewer.identityKey.matches(this.header.sender.identityKey)) {
                secret = yield viewer.sharedSecret(header.recipient, header.sender.preKey, false);
            }
            else {
                secret = yield viewer.sharedSecret(header.sender, header.recipient.preKey, true);
            }
            const decryptedBytes = yield decrypt(this.ciphertext, secret, this.headerBytes);
            this._invitation = InvitationV1.fromBytes(decryptedBytes);
            return this._invitation;
        });
    }
    toBytes() {
        return invitation.SealedInvitationV1.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new SealedInvitationV1(invitation.SealedInvitationV1.decode(bytes));
    }
}
/**
 * Wrapper class for SealedInvitationV1 and any future iterations of SealedInvitation
 */
export class SealedInvitation {
    constructor({ v1 }) {
        if (!v1) {
            throw new Error('Missing v1 invitation');
        }
        this.v1 = new SealedInvitationV1(v1);
    }
    toBytes() {
        return invitation.SealedInvitation.encode(this).finish();
    }
    static fromBytes(bytes) {
        return new SealedInvitation(invitation.SealedInvitation.decode(bytes));
    }
    static fromEnvelope(env) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!env.message || !env.timestampNs) {
                throw new Error('invalid invitation envelope');
            }
            const sealed = SealedInvitation.fromBytes(b64Decode(env.message));
            const envelopeTime = Long.fromString(env.timestampNs);
            const headerTime = sealed.v1.header.createdNs;
            if (!headerTime.equals(envelopeTime)) {
                throw new Error('envelope and header timestamp mistmatch');
            }
            return sealed;
        });
    }
    /**
     * Create a SealedInvitation with a SealedInvitationV1 payload
     * Will encrypt all contents and validate inputs
     */
    static createV1({ sender, recipient, created, invitation, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const headerBytes = new SealedInvitationHeaderV1({
                sender: sender.getPublicKeyBundle(),
                recipient,
                createdNs: dateToNs(created),
            }).toBytes();
            const secret = yield sender.sharedSecret(recipient, sender.getCurrentPreKey().publicKey, false);
            const invitationBytes = invitation.toBytes();
            const ciphertext = yield encrypt(invitationBytes, secret, headerBytes);
            return new SealedInvitation({ v1: { headerBytes, ciphertext } });
        });
    }
}
//# sourceMappingURL=Invitation.js.map