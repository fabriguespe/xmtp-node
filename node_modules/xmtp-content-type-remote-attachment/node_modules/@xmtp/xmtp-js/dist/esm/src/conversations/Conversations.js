var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
import { Mutex } from 'async-mutex';
import { SignedPublicKeyBundle } from './../crypto/PublicKeyBundle';
import { ConversationV1, ConversationV2, } from './Conversation';
import { MessageV1, DecodedMessage } from '../Message';
import Stream from '../Stream';
import { buildUserIntroTopic, buildUserInviteTopic } from '../utils';
import { SealedInvitation, InvitationV1 } from '../Invitation';
import { PublicKeyBundle } from '../crypto';
import { fetcher } from '@xmtp/proto';
import { SortDirection } from '../ApiClient';
const { b64Decode } = fetcher;
const CLOCK_SKEW_OFFSET_MS = 10000;
const messageHasHeaders = (msg) => {
    return Boolean(msg.recipientAddress && msg.senderAddress);
};
export class ConversationCache {
    constructor() {
        this.conversations = [];
        this.mutex = new Mutex();
        this.seenTopics = new Set();
    }
    load(loader) {
        return __awaiter(this, void 0, void 0, function* () {
            const release = yield this.mutex.acquire();
            try {
                const newConvos = yield loader({
                    latestSeen: this.latestSeen,
                    existing: this.conversations,
                });
                for (const convo of newConvos) {
                    if (!this.seenTopics.has(convo.topic)) {
                        this.seenTopics.add(convo.topic);
                        this.conversations.push(convo);
                        if (!this.latestSeen || convo.createdAt > this.latestSeen) {
                            this.latestSeen = convo.createdAt;
                        }
                    }
                }
                // No catch block so that errors still bubble
            }
            finally {
                release();
            }
            return [...this.conversations];
        });
    }
}
/**
 * Conversations allows you to view ongoing 1:1 messaging sessions with another wallet
 */
export default class Conversations {
    constructor(client) {
        this.client = client;
        this.v1Cache = new ConversationCache();
        this.v2Cache = new ConversationCache();
    }
    /**
     * List all conversations with the current wallet found in the network, deduped by peer address
     */
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            const [v1Convos, v2Convos] = yield Promise.all([
                this.listV1Conversations(),
                this.listV2Conversations(),
            ]);
            const conversations = v1Convos.concat(v2Convos);
            conversations.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
            return conversations;
        });
    }
    listV1Conversations() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.v1Cache.load(({ latestSeen }) => __awaiter(this, void 0, void 0, function* () {
                const seenPeers = yield this.getIntroductionPeers({
                    startTime: latestSeen
                        ? new Date(+latestSeen - CLOCK_SKEW_OFFSET_MS)
                        : undefined,
                    direction: SortDirection.SORT_DIRECTION_ASCENDING,
                });
                return Array.from(seenPeers).map(([peerAddress, sent]) => new ConversationV1(this.client, peerAddress, sent));
            }));
        });
    }
    listV2Conversations() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.v2Cache.load(({ latestSeen }) => __awaiter(this, void 0, void 0, function* () { return this.v2ConversationLoader(latestSeen); }));
        });
    }
    // Callback called in listV2Conversations and in newConversation
    v2ConversationLoader(latestSeen) {
        return __awaiter(this, void 0, void 0, function* () {
            const newConvos = [];
            const invites = yield this.client.listInvitations({
                startTime: latestSeen
                    ? new Date(+latestSeen - CLOCK_SKEW_OFFSET_MS)
                    : undefined,
                direction: SortDirection.SORT_DIRECTION_ASCENDING,
            });
            for (const sealed of invites) {
                try {
                    const unsealed = yield sealed.v1.getInvitation(this.client.keys);
                    newConvos.push(yield ConversationV2.create(this.client, unsealed, sealed.v1.header));
                }
                catch (e) {
                    console.warn('Error decrypting invitation', e);
                }
            }
            return newConvos;
        });
    }
    /**
     * Returns a stream of any newly created conversations.
     * Will dedupe to not return the same conversation twice in the same stream.
     * Does not dedupe any other previously seen conversations
     */
    stream() {
        return __awaiter(this, void 0, void 0, function* () {
            const seenPeers = new Set();
            const introTopic = buildUserIntroTopic(this.client.address);
            const inviteTopic = buildUserInviteTopic(this.client.address);
            const newPeer = (peerAddress) => {
                // Check if we have seen the peer already in this stream
                if (seenPeers.has(peerAddress)) {
                    return false;
                }
                seenPeers.add(peerAddress);
                return true;
            };
            const decodeConversation = (env) => __awaiter(this, void 0, void 0, function* () {
                if (env.contentTopic === introTopic) {
                    const messageBytes = b64Decode(env.message);
                    const msg = yield MessageV1.fromBytes(messageBytes);
                    yield msg.decrypt(this.client.legacyKeys);
                    const peerAddress = this.getPeerAddress(msg);
                    if (!newPeer(peerAddress)) {
                        return undefined;
                    }
                    return new ConversationV1(this.client, peerAddress, msg.sent);
                }
                if (env.contentTopic === inviteTopic) {
                    const sealed = yield SealedInvitation.fromEnvelope(env);
                    const unsealed = yield sealed.v1.getInvitation(this.client.keys);
                    return yield ConversationV2.create(this.client, unsealed, sealed.v1.header);
                }
                throw new Error('unrecognized invite topic');
            });
            return Stream.create(this.client, [inviteTopic, introTopic], decodeConversation.bind(this));
        });
    }
    /**
     * Streams messages from all conversations.
     *
     * When a new conversation is initiated with the client's address, this function will automatically register it and add it to the list of conversations to watch.
     * Callers should be aware the first messages in a newly created conversation are picked up on a best effort basis and there are other potential race conditions which may cause some newly created conversations to be missed.
     *
     */
    streamAllMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            const introTopic = buildUserIntroTopic(this.client.address);
            const inviteTopic = buildUserInviteTopic(this.client.address);
            const topics = new Set([introTopic, inviteTopic]);
            const convoMap = new Map();
            for (const conversation of yield this.list()) {
                topics.add(conversation.topic);
                convoMap.set(conversation.topic, conversation);
            }
            const decodeMessage = (env) => __awaiter(this, void 0, void 0, function* () {
                const contentTopic = env.contentTopic;
                if (!contentTopic) {
                    return null;
                }
                if (contentTopic === introTopic) {
                    const messageBytes = b64Decode(env.message);
                    const msg = yield MessageV1.fromBytes(messageBytes);
                    if (!messageHasHeaders(msg)) {
                        return null;
                    }
                    // Decrypt the message to ensure it hasn't been spoofed
                    yield msg.decrypt(this.client.legacyKeys);
                    const peerAddress = msg.senderAddress === this.client.address
                        ? msg.recipientAddress
                        : msg.senderAddress;
                    // Temporarily create a convo to decrypt the message
                    const convo = new ConversationV1(this.client, peerAddress, msg.sent);
                    return convo.decodeMessage(env);
                }
                // Decode as an invite and return the envelope
                // This gives the contentTopicUpdater everything it needs to add to the topic list
                if (contentTopic === inviteTopic) {
                    const sealed = yield SealedInvitation.fromEnvelope(env);
                    const unsealed = yield sealed.v1.getInvitation(this.client.keys);
                    return ConversationV2.create(this.client, unsealed, sealed.v1.header);
                }
                const convo = convoMap.get(contentTopic);
                // Decode as a V1 message if the topic matches a V1 convo
                if (convo instanceof ConversationV1) {
                    return convo.decodeMessage(env);
                }
                // Decode as a V2 message if the topic matches a V2 convo
                if (convo instanceof ConversationV2) {
                    return convo.decodeMessage(env);
                }
                console.log('Unknown topic');
                throw new Error('Unknown topic');
            });
            const addConvo = (topic, conversation) => {
                if (topics.has(topic)) {
                    return false;
                }
                convoMap.set(topic, conversation);
                topics.add(topic);
                return true;
            };
            const contentTopicUpdater = (msg) => {
                // If we have a V1 message from the introTopic, store the conversation in our mapping
                if (msg instanceof DecodedMessage && msg.contentTopic === introTopic) {
                    const convo = new ConversationV1(this.client, msg.recipientAddress === this.client.address
                        ? msg.senderAddress
                        : msg.recipientAddress, msg.sent);
                    const isNew = addConvo(convo.topic, convo);
                    return isNew ? Array.from(topics.values()) : undefined;
                }
                if (msg instanceof ConversationV2) {
                    const isNew = addConvo(msg.topic, msg);
                    return isNew ? Array.from(topics.values()) : undefined;
                }
                return undefined;
            };
            const str = yield Stream.create(this.client, Array.from(topics.values()), decodeMessage, contentTopicUpdater);
            return (function generate() {
                return __asyncGenerator(this, arguments, function* generate_1() {
                    var e_1, _a;
                    try {
                        for (var str_1 = __asyncValues(str), str_1_1; str_1_1 = yield __await(str_1.next()), !str_1_1.done;) {
                            const val = str_1_1.value;
                            if (val instanceof DecodedMessage) {
                                yield yield __await(val);
                            }
                            // For conversation V2, we may have messages in the new topic before we started streaming.
                            // To be safe, we fetch all messages
                            if (val instanceof ConversationV2) {
                                for (const convoMessage of yield __await(val.messages())) {
                                    yield yield __await(convoMessage);
                                }
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) yield __await(_a.call(str_1));
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                });
            })();
        });
    }
    getIntroductionPeers(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const messages = yield this.client.listEnvelopes([buildUserIntroTopic(this.client.address)], (env) => __awaiter(this, void 0, void 0, function* () {
                const msg = yield MessageV1.fromBytes(b64Decode(env.message));
                // Decrypt the message to ensure it is valid. Ignore the contents
                yield msg.decrypt(this.client.legacyKeys);
                return msg;
            }), opts);
            const seenPeers = new Map();
            for (const message of messages) {
                // Ignore all messages without sender or recipient address headers
                // Makes getPeerAddress safe
                if (!messageHasHeaders(message)) {
                    continue;
                }
                const peerAddress = this.getPeerAddress(message);
                if (peerAddress) {
                    const have = seenPeers.get(peerAddress);
                    if (!have || have > message.sent) {
                        seenPeers.set(peerAddress, message.sent);
                    }
                }
            }
            return seenPeers;
        });
    }
    /**
     * Creates a new conversation for the given address. Will throw an error if the peer is not found in the XMTP network
     */
    newConversation(peerAddress, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let contact = yield this.client.getUserContact(peerAddress);
            if (!contact) {
                throw new Error(`Recipient ${peerAddress} is not on the XMTP network`);
            }
            // If this is a V1 conversation continuation
            if (contact instanceof PublicKeyBundle && !(context === null || context === void 0 ? void 0 : context.conversationId)) {
                return new ConversationV1(this.client, peerAddress, new Date());
            }
            // If no conversationId, check and see if we have an existing V1 conversation
            if (!(context === null || context === void 0 ? void 0 : context.conversationId)) {
                const v1Convos = yield this.listV1Conversations();
                const matchingConvo = v1Convos.find((convo) => convo.peerAddress === peerAddress);
                // If intro already exists, return V1 conversation
                // if both peers have V1 compatible key bundles
                if (matchingConvo) {
                    if (!this.client.keys.getPublicKeyBundle().isFromLegacyBundle()) {
                        throw new Error('cannot resume pre-existing V1 conversation; client keys not compatible');
                    }
                    if (!(contact instanceof PublicKeyBundle) &&
                        !contact.isFromLegacyBundle()) {
                        throw new Error('cannot resume pre-existing V1 conversation; peer keys not compatible');
                    }
                    return matchingConvo;
                }
            }
            // Coerce the contact into a V2 bundle
            if (contact instanceof PublicKeyBundle) {
                contact = SignedPublicKeyBundle.fromLegacyBundle(contact);
            }
            // Define a function for matching V2 conversations
            const matcherFn = (convo) => {
                var _a;
                return convo.peerAddress === peerAddress &&
                    isMatchingContext(context, (_a = convo.context) !== null && _a !== void 0 ? _a : undefined);
            };
            let v2Convo;
            // Perform all read/write operations on the cache while holding the mutex
            yield this.v2Cache.load(({ latestSeen, existing }) => __awaiter(this, void 0, void 0, function* () {
                // First check the cache without doing a network request
                const existingMatch = existing.find(matcherFn);
                if (existingMatch) {
                    v2Convo = existingMatch;
                    return [];
                }
                // Next try and load new items into the cache from the network
                const newItems = yield this.v2ConversationLoader(latestSeen);
                const newItemMatch = newItems.find(matcherFn);
                // If one of those matches, return it to update the cache
                if (newItemMatch) {
                    v2Convo = newItemMatch;
                    return newItems;
                }
                // If all else fails, create a new invite
                const invitation = InvitationV1.createRandom(context);
                const sealedInvite = yield this.sendInvitation(contact, invitation, new Date());
                v2Convo = yield ConversationV2.create(this.client, invitation, sealedInvite.v1.header);
                return [v2Convo];
            }));
            // Keep the typechecker happy
            // v2Convo should never actually be undefined. An error in the loader will bubble and halt execution
            if (!v2Convo) {
                throw new Error('Failed to create conversation');
            }
            return v2Convo;
        });
    }
    /**
     * Exports all conversations to a JSON serializable list that can be stored in your application.
     * WARNING: Be careful with where you store this data. It contains encryption keys for V2 conversations, which can be used to read/write messages.
     */
    export() {
        return __awaiter(this, void 0, void 0, function* () {
            const conversations = yield this.list();
            return conversations.map((convo) => convo.export());
        });
    }
    /**
     * Import a list of conversations exported using `conversations.export()`.
     * This list must be exhaustive, as the SDK will only look for conversations
     * started after the last imported conversation (-30 seconds) in subsequent calls to `conversations.list()`
     */
    import(convoExports) {
        return __awaiter(this, void 0, void 0, function* () {
            const v1Exports = [];
            const v2Exports = [];
            let failed = 0;
            for (const convoExport of convoExports) {
                try {
                    if (convoExport.version === 'v1') {
                        v1Exports.push(ConversationV1.fromExport(this.client, convoExport));
                    }
                    else if (convoExport.version === 'v2') {
                        v2Exports.push(ConversationV2.fromExport(this.client, convoExport));
                    }
                }
                catch (e) {
                    console.log('Failed to import conversation', e);
                    failed += 1;
                }
            }
            yield Promise.all([
                this.v1Cache.load(() => __awaiter(this, void 0, void 0, function* () { return v1Exports; })),
                this.v2Cache.load(() => __awaiter(this, void 0, void 0, function* () { return v2Exports; })),
            ]);
            return failed;
        });
    }
    sendInvitation(recipient, invitation, created) {
        return __awaiter(this, void 0, void 0, function* () {
            const sealed = yield SealedInvitation.createV1({
                sender: this.client.keys,
                recipient,
                created,
                invitation,
            });
            const peerAddress = yield recipient.walletSignatureAddress();
            this.client.publishEnvelopes([
                {
                    contentTopic: buildUserInviteTopic(peerAddress),
                    message: sealed.toBytes(),
                    timestamp: created,
                },
                {
                    contentTopic: buildUserInviteTopic(this.client.address),
                    message: sealed.toBytes(),
                    timestamp: created,
                },
            ]);
            return sealed;
        });
    }
    getPeerAddress(message) {
        const peerAddress = message.recipientAddress === this.client.address
            ? message.senderAddress
            : message.recipientAddress;
        // This assertion is safe, so long as messages have been through the filter
        return peerAddress;
    }
}
function isMatchingContext(contextA, contextB) {
    // Use == to allow null and undefined to be equivalent
    return (contextA === null || contextA === void 0 ? void 0 : contextA.conversationId) === (contextB === null || contextB === void 0 ? void 0 : contextB.conversationId);
}
//# sourceMappingURL=Conversations.js.map