import { PublicKeyBundle, SignedPublicKeyBundle, PrivateKeyBundleV1, PrivateKeyBundleV2, Signature } from './crypto';
import { EnvelopeMapper } from './utils';
import { Signer } from './types/Signer';
import { Conversations } from './conversations';
import { ContentTypeId, ContentCodec } from './MessageContent';
import { content as proto, messageApi } from '@xmtp/proto';
import ApiClient, { ApiUrls, PublishParams } from './ApiClient';
import { SealedInvitation } from './Invitation';
import { Flatten } from './utils/typedefs';
import { Keystore } from './keystore';
declare const Compression: typeof proto.Compression;
export declare type ListMessagesOptions = {
    checkAddresses?: boolean;
    startTime?: Date;
    endTime?: Date;
    limit?: number;
    direction?: messageApi.SortDirection;
};
export declare type ListMessagesPaginatedOptions = {
    startTime?: Date;
    endTime?: Date;
    pageSize?: number;
    direction?: messageApi.SortDirection;
};
export declare enum KeyStoreType {
    networkTopicStoreV1 = 0,
    static = 1
}
export { Compression };
export declare type SendOptions = {
    contentType?: ContentTypeId;
    contentFallback?: string;
    compression?: proto.Compression;
    timestamp?: Date;
};
/**
 * Network startup options
 */
declare type NetworkOptions = {
    env: keyof typeof ApiUrls;
    apiUrl: string | undefined;
    appVersion?: string;
};
declare type ContentOptions = {
    codecs: ContentCodec<any>[];
    maxContentSize: number;
};
declare type KeyStoreOptions = {
    /** Specify the keyStore which should be used for loading or saving privateKeyBundles */
    keyStoreType: KeyStoreType;
    privateKeyOverride?: Uint8Array;
};
declare type LegacyOptions = {
    publishLegacyContact?: boolean;
};
/**
 * Aggregate type for client options. Optional properties are used when the default value is calculated on invocation, and are computed
 * as needed by each function. All other defaults are specified in defaultOptions.
 */
export declare type ClientOptions = Flatten<NetworkOptions & KeyStoreOptions & ContentOptions & LegacyOptions>;
/**
 * Provide a default client configuration. These settings can be used on their own, or as a starting point for custom configurations
 *
 * @param opts additional options to override the default settings
 */
export declare function defaultOptions(opts?: Partial<ClientOptions>): ClientOptions;
/**
 * Client class initiates connection to the XMTP network.
 * Should be created with `await Client.create(options)`
 */
export default class Client {
    address: string;
    legacyKeys: PrivateKeyBundleV1;
    keys: PrivateKeyBundleV2;
    keystore: Keystore;
    apiClient: ApiClient;
    contacts: Set<string>;
    private knownPublicKeyBundles;
    private _conversations;
    private _codecs;
    private _maxContentSize;
    constructor(keys: PrivateKeyBundleV1, apiClient: ApiClient, keystore: Keystore);
    /**
     * @type {Conversations}
     */
    get conversations(): Conversations;
    get publicKeyBundle(): PublicKeyBundle;
    /**
     * Create and start a client associated with given wallet.
     *
     * @param wallet the wallet as a Signer instance
     * @param opts specify how to to connect to the network
     */
    static create(wallet: Signer | null, opts?: Partial<ClientOptions>): Promise<Client>;
    static getKeys(wallet: Signer | null, opts?: Partial<ClientOptions>): Promise<Uint8Array>;
    private init;
    close(): Promise<void>;
    private ensureUserContactPublished;
    publishUserContact(legacy?: boolean): Promise<void>;
    /**
     * Returns the cached PublicKeyBundle if one is known for the given address or fetches
     * one from the network
     *
     * This throws if either the address is invalid or the contact is not published.
     * See also [#canMessage].
     */
    getUserContact(peerAddress: string): Promise<PublicKeyBundle | SignedPublicKeyBundle | undefined>;
    /**
     * Identical to getUserContact but for multiple peer addresses
     */
    getUserContacts(peerAddresses: string[]): Promise<(PublicKeyBundle | SignedPublicKeyBundle | undefined)[]>;
    /**
     * Used to force getUserContact fetch contact from the network.
     */
    forgetContact(peerAddress: string): void;
    canMessage(peerAddress: string): Promise<boolean>;
    canMessage(peerAddress: string[]): Promise<boolean[]>;
    static canMessage(peerAddress: string, opts?: Partial<NetworkOptions>): Promise<boolean>;
    static canMessage(peerAddress: string[], opts?: Partial<NetworkOptions>): Promise<boolean[]>;
    private validateEnvelope;
    publishEnvelopes(envelopes: PublishParams[]): Promise<void>;
    registerCodec(codec: ContentCodec<any>): void;
    codecFor(contentType: ContentTypeId): ContentCodec<any> | undefined;
    encodeContent(content: any, options?: SendOptions): Promise<Uint8Array>;
    listInvitations(opts?: ListMessagesOptions): Promise<SealedInvitation[]>;
    listEnvelopes<Out>(topics: string[], mapper: EnvelopeMapper<Out>, opts?: ListMessagesOptions): Promise<Out[]>;
    /**
     * List messages on a given set of content topics, yielding one page at a time
     */
    listEnvelopesPaginated<Out>(contentTopics: string[], mapper: EnvelopeMapper<Out>, opts?: ListMessagesPaginatedOptions): AsyncGenerator<Out[]>;
    signBytes(bytes: Uint8Array): Promise<Signature>;
}
