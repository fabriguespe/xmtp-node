import Long from 'long';
import { SignedPublicKeyBundle } from './crypto/PublicKeyBundle';
import { messageApi, invitation } from '@xmtp/proto';
import Ciphertext from './crypto/Ciphertext';
import { PrivateKeyBundleV2 } from './crypto/PrivateKeyBundle';
export declare type InvitationContext = {
    conversationId: string;
    metadata: {
        [k: string]: string;
    };
};
/**
 * InvitationV1 is a protobuf message to be encrypted and used as the ciphertext in a SealedInvitationV1 message
 */
export declare class InvitationV1 implements invitation.InvitationV1 {
    topic: string;
    context: InvitationContext | undefined;
    aes256GcmHkdfSha256: invitation.InvitationV1_Aes256gcmHkdfsha256;
    constructor({ topic, context, aes256GcmHkdfSha256, }: invitation.InvitationV1);
    static createRandom(context?: invitation.InvitationV1_Context): InvitationV1;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): InvitationV1;
}
/**
 * SealedInvitationHeaderV1 is a protobuf message to be used as the headerBytes in a SealedInvitationV1
 */
export declare class SealedInvitationHeaderV1 implements invitation.SealedInvitationHeaderV1 {
    sender: SignedPublicKeyBundle;
    recipient: SignedPublicKeyBundle;
    createdNs: Long;
    constructor({ sender, recipient, createdNs, }: invitation.SealedInvitationHeaderV1);
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitationHeaderV1;
}
export declare class SealedInvitationV1 implements invitation.SealedInvitationV1 {
    headerBytes: Uint8Array;
    ciphertext: Ciphertext;
    private _header?;
    private _invitation?;
    constructor({ headerBytes, ciphertext }: invitation.SealedInvitationV1);
    /**
     * Accessor method for the full header object
     */
    get header(): SealedInvitationHeaderV1;
    /**
     * getInvitation decrypts and returns the InvitationV1 stored in the ciphertext of the Sealed Invitation
     */
    getInvitation(viewer: PrivateKeyBundleV2): Promise<InvitationV1>;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitationV1;
}
/**
 * Wrapper class for SealedInvitationV1 and any future iterations of SealedInvitation
 */
export declare class SealedInvitation implements invitation.SealedInvitation {
    v1: SealedInvitationV1;
    constructor({ v1 }: invitation.SealedInvitation);
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SealedInvitation;
    static fromEnvelope(env: messageApi.Envelope): Promise<SealedInvitation>;
    /**
     * Create a SealedInvitation with a SealedInvitationV1 payload
     * Will encrypt all contents and validate inputs
     */
    static createV1({ sender, recipient, created, invitation, }: {
        sender: PrivateKeyBundleV2;
        recipient: SignedPublicKeyBundle;
        created: Date;
        invitation: InvitationV1;
    }): Promise<SealedInvitation>;
}
