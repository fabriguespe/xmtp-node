import { PublicKeyBundle } from './crypto/PublicKeyBundle';
export declare enum EncryptionAlgorithm {
    AES_256_GCM_HKDF_SHA_256 = 0
}
/**
 * TopicKeyRecord encapsulates the key, algorithm, and a list of allowed signers
 */
export declare type TopicKeyRecord = {
    keyMaterial: Uint8Array;
    encryptionAlgorithm: EncryptionAlgorithm;
    allowedSigners: PublicKeyBundle[];
};
/**
 * TopicResult is the public interface for receiving a TopicKey
 */
export declare type TopicResult = {
    topicKey: TopicKeyRecord;
    contentTopic: string;
};
/**
 * Custom error type for cases where the caller attempted to add a second key to the same topic
 */
export declare class DuplicateTopicError extends Error {
    constructor(topic: string);
}
/**
 * TopicKeyManager stores the mapping between topics -> keys and wallet addresses -> keys
 */
export default class TopicKeyManager {
    private topicKeys;
    private dmTopics;
    constructor();
    /**
     * Create a TopicKeyRecord for the topic and store it for later access
     *
     * @param contentTopic The topic
     * @param key TopicKeyRecord that contains the topic key and encryption algorithm
     * @param counterparty The other user's PublicKeyBundle
     * @param createdAt Date
     */
    addDirectMessageTopic(contentTopic: string, key: TopicKeyRecord, counterparty: PublicKeyBundle, createdAt: Date): void;
    /**
     * Would be used to get all information required to decrypt/validate a given message
     */
    getByTopic(contentTopic: string): TopicResult | undefined;
    /**
     *  Used to know which topic/key to use to send to a given wallet address
     */
    getLatestByWalletAddress(walletAddress: string): TopicResult | undefined;
    /**
     * Used to get the topic list to listen for all messages from a given wallet address
     */
    getAllByWalletAddress(walletAddress: string): TopicResult[];
}
