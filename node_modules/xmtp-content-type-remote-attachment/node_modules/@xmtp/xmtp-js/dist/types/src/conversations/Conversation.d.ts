import { DecodedMessage } from './../Message';
import Stream from '../Stream';
import Client, { ListMessagesOptions, ListMessagesPaginatedOptions, SendOptions } from '../Client';
import { InvitationContext, InvitationV1, SealedInvitationHeaderV1 } from '../Invitation';
import { MessageV1, MessageV2 } from '../Message';
import { messageApi } from '@xmtp/proto';
import { PreparedMessage } from '../PreparedMessage';
declare type ConversationV1Export = {
    version: 'v1';
    peerAddress: string;
    createdAt: string;
};
declare type ConversationV2Export = {
    version: 'v2';
    topic: string;
    keyMaterial: string;
    createdAt: string;
    peerAddress: string;
    context: InvitationContext | undefined;
};
export declare type ConversationExport = ConversationV1Export | ConversationV2Export;
/**
 * Conversation class allows you to view, stream, and send messages to/from a peer address
 */
export declare class ConversationV1 {
    peerAddress: string;
    createdAt: Date;
    context: null;
    private client;
    constructor(client: Client, address: string, createdAt: Date);
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts?: ListMessagesOptions): Promise<DecodedMessage[]>;
    decryptBatch(messages: MessageV1[], topic: string, throwOnError?: boolean): Promise<DecodedMessage[]>;
    private buildDecryptRequest;
    private buildDecodedMessage;
    messagesPaginated(opts?: ListMessagesPaginatedOptions): AsyncGenerator<DecodedMessage[]>;
    decodeMessage(env: messageApi.Envelope): Promise<DecodedMessage>;
    get topic(): string;
    prepareMessage(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<PreparedMessage>;
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages(): Promise<Stream<DecodedMessage>>;
    export(): ConversationV1Export;
    static fromExport(client: Client, data: ConversationV1Export): ConversationV1;
    decodeEnvelope({ message, contentTopic, }: messageApi.Envelope): Promise<MessageV1>;
    /**
     * Send a message into the conversation
     */
    send(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<DecodedMessage>;
    private encodeMessage;
    private validateKeystoreResponse;
    get clientAddress(): string;
}
export declare class ConversationV2 {
    topic: string;
    private keyMaterial;
    context?: InvitationContext;
    private client;
    createdAt: Date;
    peerAddress: string;
    constructor(client: Client, topic: string, keyMaterial: Uint8Array, peerAddress: string, createdAt: Date, context: InvitationContext | undefined);
    static create(client: Client, invitation: InvitationV1, header: SealedInvitationHeaderV1): Promise<ConversationV2>;
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts?: ListMessagesOptions): Promise<DecodedMessage[]>;
    messagesPaginated(opts?: ListMessagesPaginatedOptions): AsyncGenerator<DecodedMessage[]>;
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages(): Promise<Stream<DecodedMessage>>;
    /**
     * Send a message into the conversation
     */
    send(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<DecodedMessage>;
    get clientAddress(): string;
    encodeMessage(content: any, options?: SendOptions): Promise<MessageV2>;
    decodeMessage(env: messageApi.Envelope): Promise<DecodedMessage>;
    prepareMessage(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<PreparedMessage>;
    export(): ConversationV2Export;
    static fromExport(client: Client, data: ConversationV2Export): ConversationV2;
}
export declare type Conversation = ConversationV1 | ConversationV2;
export {};
