import { InvitationContext } from './../Invitation';
import { Conversation, ConversationExport } from './Conversation';
import { DecodedMessage } from '../Message';
import Stream from '../Stream';
import Client from '../Client';
declare type CacheLoader = (args: {
    latestSeen: Date | undefined;
    existing: Conversation[];
}) => Promise<Conversation[]>;
export declare class ConversationCache {
    private conversations;
    private mutex;
    private latestSeen?;
    private seenTopics;
    constructor();
    load(loader: CacheLoader): Promise<Conversation[]>;
}
/**
 * Conversations allows you to view ongoing 1:1 messaging sessions with another wallet
 */
export default class Conversations {
    private client;
    private v1Cache;
    private v2Cache;
    constructor(client: Client);
    /**
     * List all conversations with the current wallet found in the network, deduped by peer address
     */
    list(): Promise<Conversation[]>;
    private listV1Conversations;
    private listV2Conversations;
    private v2ConversationLoader;
    /**
     * Returns a stream of any newly created conversations.
     * Will dedupe to not return the same conversation twice in the same stream.
     * Does not dedupe any other previously seen conversations
     */
    stream(): Promise<Stream<Conversation>>;
    /**
     * Streams messages from all conversations.
     *
     * When a new conversation is initiated with the client's address, this function will automatically register it and add it to the list of conversations to watch.
     * Callers should be aware the first messages in a newly created conversation are picked up on a best effort basis and there are other potential race conditions which may cause some newly created conversations to be missed.
     *
     */
    streamAllMessages(): Promise<AsyncGenerator<DecodedMessage>>;
    private getIntroductionPeers;
    /**
     * Creates a new conversation for the given address. Will throw an error if the peer is not found in the XMTP network
     */
    newConversation(peerAddress: string, context?: InvitationContext): Promise<Conversation>;
    /**
     * Exports all conversations to a JSON serializable list that can be stored in your application.
     * WARNING: Be careful with where you store this data. It contains encryption keys for V2 conversations, which can be used to read/write messages.
     */
    export(): Promise<ConversationExport[]>;
    /**
     * Import a list of conversations exported using `conversations.export()`.
     * This list must be exhaustive, as the SDK will only look for conversations
     * started after the last imported conversation (-30 seconds) in subsequent calls to `conversations.list()`
     */
    import(convoExports: ConversationExport[]): Promise<number>;
    private sendInvitation;
    private getPeerAddress;
}
export {};
