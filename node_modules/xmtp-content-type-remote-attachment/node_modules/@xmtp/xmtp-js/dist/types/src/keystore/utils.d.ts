import { TopicData } from './interfaces';
import { publicKey, keystore, invitation } from '@xmtp/proto';
import { PublicKeyBundle, SignedPublicKeyBundle } from '../crypto';
import { KeystoreError } from './errors';
export declare const convertError: (e: Error, errorCode: keystore.ErrorCode) => KeystoreError;
export declare const wrapResult: <T>(result: T) => {
    result: T;
};
declare type ResultOrError<T> = {
    result: T;
} | {
    error: KeystoreError;
};
export declare const mapAndConvertErrors: <Input, Output>(input: Input[], mapper: (input: Input) => Output | Promise<Output>, errorCode: keystore.ErrorCode) => Promise<ResultOrError<Output>[]>;
export declare const toPublicKeyBundle: (bundle: publicKey.PublicKeyBundle) => PublicKeyBundle;
export declare const toSignedPublicKeyBundle: (bundle: publicKey.SignedPublicKeyBundle) => SignedPublicKeyBundle;
export declare type WithoutUndefined<T> = {
    [P in keyof T]: NonNullable<T[P]>;
};
export declare const validateObject: <T>(obj: T, objectFields: (keyof T)[], arrayFields: (keyof T)[]) => obj is WithoutUndefined<T>;
export declare const getKeyMaterial: (invite: invitation.InvitationV1 | undefined) => Uint8Array;
export declare const topicDataToConversationReference: ({ invitation, createdNs, }: TopicData) => keystore.ConversationReference;
export declare const isCompleteTopicData: (obj: keystore.TopicMap_TopicData) => obj is WithoutUndefined<keystore.TopicMap_TopicData>;
export declare const typeSafeTopicMap: (topicMap: keystore.TopicMap) => {
    [k: string]: WithoutUndefined<keystore.TopicMap_TopicData>;
};
export {};
